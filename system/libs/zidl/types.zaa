//
// zidl.types
//

import std.string : String;
import std.range : Range;
import std.span : Span;
import os.zaos.fcntl;
import std.fmt;

extern fn thread_ring() -> os::ioring mut &;

pub struct string
{
  pub usize len;
  pub u8 *data;

  pub string(String &str)
    : data(str.data), len(str.len)
  {
  }

  pub fn String(this &) -> std::string_view
  {
    return std::string_view(this.data, this.len);
  }

  pub fn ==(string &lhs, String &rhs) -> bool
  {
    return std::string_view(lhs.data, lhs.len) == rhs;
  }

  pub fn ~=(std::string_literal lhs, string &rhs) -> bool
  {
    return lhs == std::string_view(rhs.data, rhs.len);
  }

  pub string() = default;
  pub string(string &that) = default;
  pub fn =(this mut &, string &that) -> string mut & = default;
  pub ~string() = default;
}

pub fn fmt(std::OutputStream mut &os, std::fmt_context mut &ctx, string str) throws(std::error) -> void
{
  std::fmt_to(&mut os, &mut ctx, std::string_view(str));
}

pub struct vector<T>
{
  pub usize len;
  pub T *data;

  pub vector(Span<T> &span)
    : data(span.data), len(span.len)
  {
  }

  pub fn Span<T>(this &) -> std::span<T>
  {
    return std::span(this.data, this.len);
  }

  pub fn begin(this &) -> T *
  {
    return this.data;
  }

  pub fn end(this &) -> T *
  {
    return this.data + this.len;
  }

  pub fn [](this &, usize index) -> T &
  {
    std::assert(index < this.len);

    return &*(this.data + index);
  }

  pub fn [](this &, T *iter)
  {
    std::assert(this.data <= iter && iter < this.data + this.len);

    return &*iter;
  }

  pub vector() = default;
  pub vector(vector &that) = default;
  pub fn =(this mut &, vector &that) -> vector mut & = default;
  pub ~vector() = default;
}

pub struct handle
{
  pub handle(i32 fd = -1)
    : fd(fd)
  {
  }

  pub handle(handle &&other)
    where __is_rvalue<typeof(other)>
  {
    this.fd = std::exchange(&mut other.fd, -1);
  }

  pub fn =(handle mut &this, handle &&other) -> handle mut &
    where __is_rvalue<typeof(other)>
  {
    this.close();

    this.fd = std::exchange(&mut other.fd, -1);

    return &this;
  }

  pub fn fd(this &) -> i32
  {
    return this.fd;
  }

  pub fn bool(this &) -> bool
  {
    return this.fd >= 0;
  }

  pub fn ==(handle &lhs, handle &rhs) -> bool
  {
    return lhs.fd == rhs.fd;
  }

  pub fn release(this mut &) -> i32
  {
    var fd = this.fd;

    this.fd = -1;

    return fd;
  }

  pub fn close(this mut &) -> void
  {
    if (this.fd >= 0)
      os::close(&mut thread_ring, this.fd);

    this.fd = -1;
  }

  pub ~handle()
  {
    if (fd >= 0)
      os::close(&mut thread_ring, this.fd);
  }

  i32 fd;
}

pub struct channel : pub handle
{
  pub fn create() throws(std::error) -> (channel, channel)
  {
    var fds = [0, 0];
    if (var rc = os::channel_create(&mut thread_ring, &fds, 0); rc < 0)
      throw std::system_error(cast<std::errc>(-rc));

    return (channel(fds[0]), channel(fds[1]));
  }

  pub fn create(channel mut &lhs, channel mut &rhs) -> i32
  {
    var fds = [0, 0];
    if (var rc = os::channel_create(&mut thread_ring, &fds, 0); rc < 0)
      return rc;

    lhs = channel(fds[0]);
    rhs = channel(fds[1]);

    return 0;
  }

  pub channel(i32 fd)
    : super(fd)
  {
  }

  pub channel() = default;
  pub channel(channel &&) = default;
  pub fn =(channel mut &, channel &&) -> channel mut & = default;
  pub ~channel() = default;
}

pub struct buffer : pub handle
{
  pub fn create(usize size) throws(std::error) -> (buffer, buffer)
  {
    var fds = [0, 0];
    if (var rc = os::buffer_create(&mut thread_ring, &fds, size, 0); rc < 0)
      throw std::system_error(cast<std::errc>(-rc));

    return (buffer(fds[0]), buffer(fds[1]));
  }

  pub fn create(buffer mut &lhs, buffer mut &rhs, usize size) -> i32
  {
    var fds = [0, 0];
    if (var rc = os::buffer_create(&mut thread_ring, &fds, size, 0); rc < 0)
      return rc;

    lhs = buffer(fds[0]);
    rhs = buffer(fds[1]);

    return 0;
  }

  pub buffer(i32 fd)
    : super(fd)
  {
  }

  pub buffer() = default;
  pub buffer(buffer &&) = default;
  pub fn =(buffer mut &, buffer &&) -> buffer mut & = default;
  pub ~buffer() = default;
}

