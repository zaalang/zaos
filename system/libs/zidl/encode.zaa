//
// zidl.encode
//

import zidl;
import std.span : Span;

pub struct encoder
{
  u8 mut *bytes_tail;
  std::mutable_span<u8> bytes;

  i32 mut *handles_tail;
  std::mutable_span<i32> handles;

  encoder(Span<u8> mut &bytes, Span<i32> mut &handles)
    : bytes(bytes.data, bytes.len),
      handles(handles.data, handles.len)
  {
    bytes_tail = bytes.data;
    handles_tail = handles.data;
  }

  pub fn alloc(this mut &, usize size) -> u8 mut *
  {
    var data = this.bytes_tail;

    this.bytes_tail += std::align_up(size, 8);

    if (this.bytes.end < this.bytes_tail)
      return null;

    std::memset(data + size, 0, std::align_up(size, 8) - size);

    return data;
  }

  pub fn submit(this mut &, i32 fd) -> bool
  {
    var handle = this.handles_tail;

    this.handles_tail += 1;

    if (this.handles.end < this.handles_tail)
      return false;

    *handle = fd;

    return true;
  }

  pub ~encoder() = default;
}

pub fn encode(encoder mut &encoder, zidl::string string) -> void
{
  if (var data = encoder.alloc(string.len))
  {
    std::memcpy(data, string.data, string.len);
  }
}

pub fn encode(encoder mut &encoder, zidl::handle &handle) -> void
{
  encoder.submit(handle.fd);
}

pub fn encode<T>(encoder mut &encoder, zidl::vector<T> vector) -> void
{
  if (var data = encoder.alloc(vector.len * sizeof<T>))
  {
    std::memcpy(data, vector.data, vector.len * sizeof<T>);

    #if (requires (encoder encoder, T object) { encode(&mut encoder, object); })
      for (var &element : vector)
        encode(&mut encoder, element);
  }
}

pub fn encode<T, N>(encoder mut &encoder, T[N] &array) -> void
  where requires (encoder encoder, T object) { encode(&mut encoder, object); }
{
  for (var i = 0; i < N; ++i)
  {
    encode(&mut encoder, array[i]);
  }
}

pub fn encode<T>(encoder mut &encoder, T &object) -> void
  where __is_struct<T>
{
  #for (const k : std::meta::fields_of($T))
  {
    #if (requires (encoder encoder, T object) { encode(&mut encoder, object.#k); })
      encode(&mut encoder, object.#k);
  }
}

pub struct encode_result
{
  pub usize bytes_actual;
  pub usize handles_actual;
  pub zidl::errc error;

  pub encode_result() = default;
  pub encode_result(encode_result&) = default;
  pub fn =(encode_result mut &, encode_result&) -> encode_result mut & = default;
  pub ~encode_result() = default;
}

pub fn encode<zidl_message_t>(Span<u8> mut &bytes, Span<i32> mut &handles, zidl_message_t &msg) -> encode_result
{
  var result = encode_result();
  var encoder = zidl::encoder(&mut bytes, &mut handles);

  if (var header = encoder.alloc(sizeof<zidl::zidl_header_t>))
  {
    var header = cast<zidl::zidl_header_t mut *>(header);

    header.magic = zidl::zidl_header_t::signature;
    header.flags = 0;
    header.ordinal = zidl_message_t::ordinal;
  }

  if (var inline = encoder.alloc(sizeof<zidl_message_t>))
  {
    std::memcpy(inline, &msg, sizeof(msg));
  }

  encode(&mut encoder, msg);

  if (bytes.end < encoder.bytes_tail)
    result.error = zidl::errc::exhausted_bytes_capacity;

  if (handles.end < encoder.handles_tail)
    result.error = zidl::errc::exhausted_handles_capacity;

  result.bytes_actual = encoder.bytes_tail - bytes.data;
  result.handles_actual = encoder.handles_tail - handles.data;

  return result;
}
