//
// animation
//

import std.stdlib;
import std.function;
import std.sys.clock;
import gfx.color;

enum animation_state
{
  starting,
  animating,
  finished,
}

pub enum animation_easing
{
  linear,
  in_quad,
  out_quad,
  in_out_quad,
  in_cubic,
  out_cubic,
  in_out_cubic,
  in_elastic,
  out_elastic,
  in_out_elastic,
  in_bounce,
  out_bounce,
  in_out_bounce,
}

pub enum animation_direction
{

}

pub struct Animation<T>
{
  pub u64 delay;
  pub u64 duration;
  pub animation_easing easing = animation_easing::linear;

  pub std::delegate<(T &) -> void> on_updated;

  T from;
  T target;
  u64 start_time;
  animation_state state = animation_state::finished;

  pub Animation() = default;
  pub ~Animation() = default;
}

fn now() -> u64
{
  try
  {
    return std::clock::tick(std::clock::id::monotonic);
  }
  catch(std::error e)
  {
    std::panic("system_clock failure");
  }
}

pub fn easing(animation_easing &curve, f32 alpha) -> f32
{
  const D1 = 2.75;
  const N1 = 7.5625;
  const C4 = (2.0 * std::PI) / 3.0;
  const C5 = (2.0 * std::PI) / 4.5;

  switch (curve)
  {
    case linear:
      return alpha;

    case in_quad:
      return std::pow(alpha, 2);

    case out_quad:
      return 1.0 - std::pow(1.0 - alpha, 2);

    case in_out_quad:
      return (alpha < 0.5) ? 2.0 * std::pow(alpha, 2) : 1.0 - 0.5*std::pow(-2.0 * alpha + 2.0, 2);

    case in_cubic:
      return std::pow(alpha, 3);

    case out_cubic:
      return 1.0 - std::pow(1.0 - alpha, 3);

    case in_out_cubic:
      return (alpha < 0.5) ? 4.0 * std::pow(alpha, 3) : 1.0 - 0.5*std::pow(-2.0 * alpha + 2.0, 3);

    case in_elastic:
      if (alpha == 0.0)
        return 0.0;
      else if (alpha == 1.0)
        return 1.0;
      else
        return -std::pow(2.0, 10.0 * alpha - 10.0) * std::sin((alpha * 10.0 - 10.75) * C4);

    case out_elastic:
      if (alpha == 0.0)
        return 0.0;
      else if (alpha == 1.0)
        return 1.0;
      else
        return std::pow(2.0, -10.0 * alpha) * std::sin((alpha * 10.0 - 0.75) * C4) + 1.0;

    case in_out_elastic:
      if (alpha == 0.0)
        return 0.0;
      else if (alpha == 1.0)
        return 1.0;
      else if (alpha < 0.5)
        return -0.5*(std::pow(2.0, 20.0 * alpha - 10.0) * std::sin((alpha * 20.0 - 11.125) * C5));
      else
        return 0.5*(std::pow(2.0, -20.0 * alpha + 10.0) * std::sin((alpha * 20.0 - 11.125) * C5)) + 1.0;

    case in_bounce:
      if (alpha < 0.25 / D1)
        return 0.015625 - N1 * (1.0 - (alpha += 2.625 / D1)) * (1.0 - alpha);
      else if (alpha < 0.75 / D1)
        return 0.0625 - N1 * (1.0 - (alpha += 2.25 / D1)) * (1.0 - alpha);
      else if (alpha < 1.75 / D1)
        return 0.25 - N1 * (1.0 - (alpha += 1.5 / D1)) * (1.0 - alpha);
      else
        return 1.0 - N1 * std::pow(1.0 - alpha, 2);

    case out_bounce:
      if (alpha < 1.0 / D1)
        return N1 * std::pow(alpha, 2);
      else if (alpha < 2.0 / D1)
        return N1 * (alpha -= 1.5 / D1) * alpha + 0.75;
      else if (alpha < 2.5 / D1)
        return N1 * (alpha -= 2.25 / D1) * alpha + 0.9375;
      else
        return N1 * (alpha -= 2.625 / D1) * alpha + 0.984375;

    case in_out_bounce:
      if (alpha < 0.5)
        return 0.5*easing(animation_easing::in_bounce, 2.0 * alpha);
      else
        return 0.5 + 0.5*easing(animation_easing::out_bounce, 2.0 * alpha - 1.0);

    else:
      std::panic("unhandled");
  }
}

pub fn interpolate(float src, float dst, f32 alpha) -> float
{
  return src + cast<float>(alpha) * (dst - src);
}

pub fn interpolate(gfx::color &src, gfx::color &dst, f32 alpha) -> gfx::color
{
  return src + alpha * (dst - src);
}

pub fn interpolate(gfx::brush &src, gfx::brush &dst, f32 alpha) -> gfx::brush
{
  return src.color + alpha * (dst.color - src.color);
}

pub fn start<T, V>(Animation<T> mut &this, T &from, V &target) -> void
{
  this.from = from;
  this.target = T(target);
  this.start_time = now();
  this.state = animation_state::starting;
}

pub fn update<T>(Animation<T> mut &this, u64 mut &deadline) -> void
{
  switch (this.state)
  {
    case starting:
      var dt = now() - this.start_time;

      if (dt < this.delay)
      {
        deadline = std::min(deadline, this.delay - dt);
      }
      else
      {
        this.state = animation_state::animating;
      }
  }

  switch (this.state)
  {
    case animating:
      var dt = now() - this.start_time - this.delay;

      if (dt < this.duration)
      {
        var alpha = std::clamp(cast<f32>(dt) / cast<f32>(this.duration), 0.0, 1.0);

        this.on_updated(interpolate(this.from, this.target, easing(this.easing, alpha)));

        deadline = 0;
      }
      else
      {
        this.on_updated(this.target);

        this.state = animation_state::finished;
      }
  }
}
