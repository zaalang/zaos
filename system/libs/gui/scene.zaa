//
// item
//

import std.stdlib;
import std.vector;
import gui.object;
import gui.painter;
import gfx.transform;
import gui.items.rectangle;
import gui.items.text;
import gui.items.toucharea;
import gui.items.focusscope;
import gui.items.input;
import gui.layouts.grid;
import gui.layouts.horizontal;
import gui.layouts.vertical;
import gui.layouts.flex;
import gui.window;

pub vtable iitem
{
  pub enum action
  {
    forward,
    accept,
    ignore,
  }

  pub enum reason
  {
    tab,
    shortcut,
    window,
    other,
  }

  fn focus_event(this mut &, scene mut &, reason, gui::focus_event &) -> action;

  fn pointer_event_filter(this mut &, scene mut &, gfx::point &, gui::pointer_event &) -> action;
  fn pointer_event(this mut &, scene mut &, gfx::point &, gui::pointer_event &) -> action;
  fn pointer_exit(this mut &, scene mut &) -> void;

  fn key_event_filter(this mut &, scene mut &, gui::key_event &) -> action;
  fn key_event(this mut &, scene mut &, gui::key_event &) -> action;

  fn render(this &, gui::painter mut &, gfx::transform &) -> void;
}

pub struct item : iitem &
{
  pub float x;
  pub float y;
  pub float width;
  pub float height;

  pub float opacity = 1.0;
  pub gfx::transform transform = gfx::transform::identity;

  pub bool visible = true;
  pub bool clip = false;

  fn *(this &) -> iitem &
  {
    return cast<iitem&>(this);
  }

  pub item(iitem &iitem)
    : super(&iitem)
  {
  }

  pub ~item() = default;
}

pub struct scene : pub gui::object
{
  struct node
  {
    item mut &item;
    usize parent_index;
    usize children_count;
    usize children_index;

    node(item mut *item, usize parent_index, usize children_count, usize children_index)
      : item(&*item), parent_index(parent_index), children_count(children_count), children_index(children_index)
    {
    }

    node(node &) = default;
    ~node() = default;
  }

  std::vector<node> nodes;

  bool grabbed;
  std::vector<usize> item_stack;
  std::vector<usize> focus_stack;

  pub fn push_back(this mut &, item mut *item, usize parent_index, usize children_count, usize children_index) -> void
  {
    this.nodes.push_back(item, parent_index, children_count, children_index);
  }

  pub scene()
    : super(&impl this)
  {
  }

  pub ~scene() = default;
}

fn set_focus(scene mut &scene, item *item, iitem::reason reason) -> void
{
  if (!scene.focus_stack.empty)
  {
    if (&scene.nodes[scene.focus_stack.back].item == item)
      return;

    var evt = gui::focus_event();
    evt.type = gui::focus_event::type::focus_out;

    var mut &item = scene.nodes[scene.focus_stack.back].item;

    item.focus_event(&mut item, &mut scene, reason, evt);

    scene.focus_stack.clear();
  }

  scene.focus_stack.push_back(scene.nodes.find_if(|node| &node.item == item) - scene.nodes.begin);

  while (scene.focus_stack.back != 0)
  {
    scene.focus_stack.push_back(scene.nodes[scene.focus_stack.back].parent_index);
  }

  std::reverse!(&mut scene.focus_stack);

  if (!scene.focus_stack.empty)
  {
    var evt = gui::focus_event();
    evt.type = gui::focus_event::type::focus_in;

    var mut &item = scene.nodes[scene.focus_stack.back].item;

    switch (item.focus_event(&mut item, &mut scene, reason, evt))
    {
      case accept:
        ;
    }
  }
}

pub fn scene_set_focus(scene mut &scene, item *item) -> void
{
  scene.set_focus(item, iitem::reason::other);
}

fn clear_focus(scene mut &scene) -> void
{
  var evt = gui::focus_event();
  evt.type = gui::focus_event::type::focus_out;

  var mut &item = scene.nodes[scene.focus_stack.back].item;

  item.focus_event(&mut item, &mut scene, iitem::reason::other, evt);

  scene.focus_stack.clear();
}

pub fn scene_clear_focus(scene mut &scene, item *item) -> void
{
  if (scene.focus_stack.empty)
    return;

  if (&scene.nodes[scene.focus_stack.back].item != item)
    return;

  scene.clear_focus();
}

fn scene_event(scene mut &scene, gfx::point &xy, gui::pointer_event &evt, usize index) -> iitem::action
{
  var mut &item = scene.nodes[index].item;

  if (!item.visible)
    return ignore;

  var xy = item.transform.inverse * gfx::transform::translation(-item.x, -item.y) * xy;

  if (gfx::rect(0.0, 0.0, item.width, item.height).contains(xy))
  {
    scene.item_stack.push_back(index);

    switch (item.pointer_event_filter(&mut item, &mut scene, xy, evt))
    {
      case forward:
        rof (var child = scene.nodes[index].children_index + scene.nodes[index].children_count, var beg = scene.nodes[index].children_index; child == beg; --child)
        {
          switch (scene_event(&mut scene, xy, evt, child))
          {
            case accept:
              return accept;
          }
        }
    }

    switch (item.pointer_event(&mut item, &mut scene, xy, evt))
    {
      case accept:
        return accept;
    }

    scene.item_stack.pop_back();
  }

  return ignore;
}

pub fn scene_event(scene mut &scene, gui::pointer_event &evt) -> void
{
  if (scene.nodes.empty)
    return;

  var evt = evt;
  var old_item_stack = scene.item_stack.take(scene.item_stack.begin, scene.item_stack.end);

  if (scene.grabbed)
  {
    var xy = gfx::point(cast<float>(evt.position.0), cast<float>(evt.position.1));

    for (var index : old_item_stack)
    {
      var mut &item = scene.nodes[index].item;

      scene.item_stack.push_back(index);

      xy = item.transform.inverse * gfx::transform::translation(-item.x, -item.y) * xy;

      switch (item.pointer_event_filter(&mut item, &mut scene, xy, evt))
      {
        case accept:
          ;
      }
    }

    if (scene.item_stack.len != 0)
    {
      var mut &item = scene.nodes[scene.item_stack.back].item;

      switch (item.pointer_event(&mut item, &mut scene, xy, evt))
      {
        case accept:
          ;
      }
    }

    if (evt.button != cast(0) && std::all_of(evt.buttons, |state| state == 0))
    {
      evt.button = cast(0);
      scene.item_stack.clear();
      scene.grabbed = false;
    }
  }

  if (!scene.grabbed)
  {
    switch (scene_event(&mut scene, gfx::point(cast<float>(evt.position.0), cast<float>(evt.position.1)), evt, 0))
    {
      case accept:
        if (evt.button != cast(0) && evt.buttons[cast(evt.button)] == 1)
          scene.grabbed = true;

      case ignore:
        if (evt.button != cast(0) && evt.buttons[cast(evt.button)] == 1)
          if (!scene.focus_stack.empty)
            scene.clear_focus();
    }
  }

  for (var i = 0, var j = 0; i < old_item_stack.len; ++i)
  {
    var mut &item = scene.nodes[old_item_stack[i]].item;

    for (; j < scene.item_stack.len; ++j)
      if (scene.item_stack[j] == old_item_stack[i])
        break;

    if (j == scene.item_stack.len)
      item.pointer_exit(&mut item, &mut scene);
  }
}

pub fn scene_event(scene mut &scene, gui::key_event &evt) -> void
{
  if (scene.nodes.empty)
    return;

  var item_stack = std::vector<usize>();

  for (var index : scene.focus_stack)
  {
    var mut &item = scene.nodes[index].item;

    if (!item.visible)
      break;

    item_stack.push_back(index);

    switch (item.key_event_filter(&mut item, &mut scene, evt))
    {
      case accept:
        break;
    }
  }

  rof (var index : item_stack)
  {
    var mut &item = scene.nodes[index].item;

    switch (item.key_event(&mut item, &mut scene, evt))
    {
      case accept:
        break;
    }
  }
}

fn scene_render(gui::painter mut &painter, gfx::transform &transform, scene &scene, usize index) -> void
{
  var &item = scene.nodes[index].item;

  if (!item.visible)
    return;

  if (item.opacity < 0.001)
    return;

  var transform = transform * gfx::transform::translation(item.x, item.y) * item.transform;

  var opacity = painter.opacity;
  painter.opacity = opacity * cast(item.opacity);

  var aabb = transform * gfx::rect(0.0, 0.0, item.width, item.height);

  if (aabb.intersects(painter.clip_rect))
  {
    item.render(item, &mut painter, transform);
  }

  if (!item.clip || aabb.intersects(painter.clip_rect))
  {
    var cliprect = painter.clip_rect;

    if (item.clip)
      painter.clip_rect = gfx::clamp(cliprect, aabb);

    for (var child = scene.nodes[index].children_index, var end = scene.nodes[index].children_index + scene.nodes[index].children_count; child < end; ++child)
    {
      scene_render(&mut painter, transform, scene, child);
    }

    painter.clip_rect = cliprect;
  }

  painter.opacity = opacity;
}

pub fn scene_render(gui::painter mut &painter, gfx::transform &transform, scene &scene) -> void
{
  if (scene.nodes.empty)
    return;

  scene_render(&mut painter, transform, scene, 0);
}

pub fn scene_render(gui::painter mut &painter, scene &scene) -> void
{
  if (scene.nodes.empty)
    return;

  scene_render(&mut painter, gfx::transform::identity, scene, 0);
}
