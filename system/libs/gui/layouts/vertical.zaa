//
// vertical layout
//

import std.stdlib;
import std.function;
import gui.painter;
import gfx.transform;

pub enum layout_vertical_alignment
{
  top,
  middle,
  bottom,
  space_between,
  space_around,
  space_evenly,
}

pub struct VerticalLayout
{
  pub float x;
  pub float y;
  pub float width;
  pub float height;

  pub float spacing;
  pub float padding_left;
  pub float padding_right;
  pub float padding_top;
  pub float padding_bottom;
  pub layout_vertical_alignment alignment = layout_vertical_alignment::top;

  pub std::vector<float> min_heights;
  pub std::vector<float> max_heights;
  pub std::vector<float> preferred_heights;
  pub std::vector<float> vertical_stretchs;

  pub std::delegate<(std::vector<gfx::rect> &) -> void> on_updated;

  pub fn padding=(this mut &, float padding) -> void
  {
    this.padding_left = padding;
    this.padding_right = padding;
    this.padding_top = padding;
    this.padding_bottom = padding;
  }

  pub VerticalLayout() = default;
  pub ~VerticalLayout() = default;
}

pub fn update(VerticalLayout mut &this) -> void
{
  var rects = std::vector<gfx::rect>::with_size(this.min_heights.len);

  var x = this.y + this.padding_left;
  var width = this.width - this.padding_left - this.padding_right;

  var remaining = this.height - this.padding_top - this.padding_bottom - cast(std::max(rects.len, 1) - 1) * this.spacing;

  for (var i = 0; i < rects.len; ++i)
  {
    rects[i] = gfx::rect(0.0, 0.0, width, std::max(this.min_heights[i], this.preferred_heights[i]));

    remaining -= rects[i].height;
  }

  for (; remaining > 0.0; )
  {
    var total_stretch = 0.0;

    for (var i = 0; i < rects.len; ++i)
    {
      if (this.max_heights[i] > 0.0 && this.max_heights[i] <= rects[i].height)
        continue;

      total_stretch += this.vertical_stretchs[i];
    }

    if (total_stretch <= 0.0)
      break;

    var consumed = 0.0;

    for (var i = 0; i < rects.len; ++i)
    {
      var growth = remaining * this.vertical_stretchs[i] / total_stretch;

      if (this.max_heights[i] > 0.0 && this.max_heights[i] < rects[i].height + growth)
        growth = this.max_heights[i] - rects[i].height;

      rects[i] = gfx::rect(0.0, 0.0, rects[i].width, rects[i].height + growth);

      consumed += growth;
    }

    if (consumed <= 0.0)
      break;

    remaining -= consumed;
  }

  for (; remaining < 0.0; )
  {
    var shrinkable = 0.0;

    for (var i = 0; i < rects.len; ++i)
    {
      if (rects[i].height <= this.min_heights[i])
        continue;

      shrinkable += 1.0;
    }

    if (shrinkable <= 0.0)
      break;

    var consumed = 0.0;

    for (var i = 0; i < rects.len; ++i)
    {
      var growth = remaining / shrinkable;

      if (rects[i].height + growth < this.min_heights[i])
        growth = this.min_heights[i] - rects[i].height;

      rects[i] = gfx::rect(0.0, 0.0, rects[i].width, rects[i].height + growth);

      consumed += growth;
    }

    if (consumed >= 0.0)
      break;

    remaining -= consumed;
  }

  switch (this.alignment)
  {
    case top:
      var y = this.y + this.padding_top;

      for (var i = 0; i < rects.len; ++i)
      {
        rects[i] = gfx::rect(x, y, rects[i].width, rects[i].height);

        y += rects[i].height + this.spacing;
      }

    case bottom:
      var y = this.y + this.height - this.padding_bottom + this.spacing;

      for (var i = 0; i < rects.len; ++i)
      {
        y -= rects[i].height + this.spacing;

        rects[i] = gfx::rect(x, y, rects[i].width, rects[i].height);
      }

    case middle:
      var y = this.y + this.padding_left + (this.height - this.padding_top - this.padding_bottom + this.spacing) / 2.0;

      for (var i = 0; i < rects.len; ++i)
      {
        y -= (rects[i].height + this.spacing) / 2.0;
      }

      for (var i = 0; i < rects.len; ++i)
      {
        rects[i] = gfx::rect(x, y, rects[i].width, rects[i].height);

        y += rects[i].height + this.spacing;
      }
  }

  this.on_updated(rects);
}
