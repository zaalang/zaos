//
// acpi ml parser
//

import acpi;
import acpi.aml as aml;
import acpi.namespace;
import std.span;
import std.string;
import std.vector;

using aml;
using acpi::value;
using acpi::result;
using acpi::namespace;

const NARGS = 7;
const NLOCALS = 8;

enum state
{
  stream_start = 0,
  pkg_length,
  byte_data,
  word_data,
  dword_data,
  qword_data,
  name_string,
  obj_string,
  num_elements,
  package_element_list,
  package_element,
  package,
  buffer,
  target,
  target_refof,
  target_derefof,
  term_list,
  term_arg,
  define_name,
  define_alias,
  define_scope,
  define_device,
  define_processor,
  define_powerres,
  define_thermalzone,
  define_method,
  define_mutex,
  define_event,
  define_field,
  define_indexfield,
  define_bankfield,
  define_opregion,
  create_field,
  create_bit_field,
  create_byte_field,
  create_word_field,
  create_dword_field,
  create_qword_field,
  if_op,
  while_op,
  break_op,
  continue_op,
  notify_op,
  l_not_op,
  l_and_op,
  l_or_op,
  l_equal_op,
  l_greater_op,
  l_less_op,
  not_op,
  and_op,
  nand_op,
  or_op,
  nor_op,
  xor_op,
  add_op,
  subtract_op,
  multiply_op,
  divide_op,
  mod_op,
  shiftleft_op,
  shiftright_op,
  increment_op,
  decrement_op,
  refof_op,
  condrefof_op,
  index_op,
  derefof_op,
  match_op,
  mid_op,
  concat_op,
  to_buffer,
  to_decimalstring,
  to_hexstring,
  to_integer,
  sizeof_op,
  acquire_op,
  release_op,
  stall_op,
  sleep_op,
  timer_op,
  fatal_op,
  load_op,
  loaded,
  return_op,
  breakpoint_op,
  method_invocation,
  method_call,
  end_scope,
  pop_frame,
  store,
  loop,
  pkg,
  pop,
  end
}

struct frame
{
  usize rip;
  usize rbp;
  usize rsp;
  acpi::node *scope;
  std::span<u8> ret;

  frame() = default;
  frame(frame &&) = default;
  ~frame() = default;
}

union operand
{
  byte(u8),
  word(u16),
  dword(u32),
  qword(u64),
  name(std::span<u8>),
  span(std::span<u8>),
  value(acpi::value),
  callee(acpi::value),
  reference(acpi::reference),

  pub fn is_value(this &) -> bool
  {
    return this.kind == typeof(this.kind)::value;
  }

  pub fn is_callee(this &) -> bool
  {
    return this.kind == typeof(this.kind)::callee;
  }

  pub fn is_reference(this &) -> bool
  {
    return this.kind == typeof(this.kind)::reference;
  }

  operand() = default;
  operand(operand &&) = default;
  fn =(operand mut &, operand &&) -> operand mut & = default;
  ~operand() = default;
}

union target
{
  nul,
  debug,
  arg(usize),
  local(usize),
  name(std::span<u8>),
  reference(acpi::reference),

  target() = default;
  target(target &&) = default;
  fn =(target mut &, target &&) -> target mut & = default;
  ~target() = default;
}

struct context
{
  state state;
  std::vector<state> text;
  std::vector<operand> stack;
  std::vector<target> targets;
  std::vector<acpi::node*> scopes;
  std::vector<(std::span<u8>, std::span<u8>)> blocks;
  std::vector<frame> frames;
  std::list<value> values;

  namespace mut &namespace;

  fn frame(this &&)
  {
    return &this.frames.back;
  }

  fn scope(this &&)
  {
    return &this.scopes.back;
  }

  fn arg(this &&, usize index)
  {
    return &this.stack[this.frame.rsp - (NARGS - index)];
  }

  fn local(this &&, usize index)
  {
    return &this.stack[this.frame.rsp + index];
  }

  fn push_state(this mut &, state state) -> void
  {
    this.text.push_back(state);
  }

  fn pop_state(this mut &) -> state
  {
    return this.text.take_back();
  }

  fn push_reference(this mut &, operand &operand) -> void
  {
    switch (operand)
    {
      case value[value]:
        this.push_operand(operand::reference(&value));

      case reference[reference]:
        this.push_operand(operand::reference(reference));

      else:
        std::panic("invalid ref");
    }
  }

  fn push_value(this mut &, value &&value) -> value mut &
  {
    std::assert(this.stack.len < this.stack.capacity, "stack exhausted");

    return &this.stack.push_back(operand::value(&&value)).value;
  }

  fn push_operand(this mut &, operand &&operand) -> operand mut &
  {
    std::assert(this.stack.len < this.stack.capacity, "stack exhausted");

    return &this.stack.push_back(&&operand);
  }

  fn push_scope(this mut &, acpi::node *scope) -> void
  {
    this.scopes.push_back(scope);
  }

  fn push_frame(this mut &, usize argc, acpi::node *scope, std::span<u8> &ret) -> void
  {
    var mut &frame = this.frames.push_back();

    frame.rip = this.text.len;
    frame.rbp = this.blocks.len;
    frame.rsp = this.stack.len + (NARGS - argc);
    frame.scope = std::allocator::new<acpi::node>(acpi::node::type::method, scope);
    frame.ret = ret;

    std::assert(this.stack.len + (NARGS - argc) + NLOCALS < this.stack.capacity, "stack exhausted");

    this.stack.resize(this.stack.len + (NARGS - argc) + NLOCALS);

    this.push_scope(frame.scope);
  }

  fn pop_frame(this mut &) -> std::span<u8>
  {
    var ret = this.frames.back.ret;

    this.scopes.pop_back();

    if (this.stack.len - this.frame.rsp == NLOCALS)
      this.push_value(value());

    this.stack.erase(this.frame.rsp - NARGS - 1, this.stack.len - (this.frame.rsp - NARGS));

    std::allocator::delete(this.frame.scope);

    this.frames.pop_back();

    return ret;
  }

  fn alloc(context mut &ctx, value &&value) -> value *
  {
    switch (ctx.scope.type)
    {
      else:
        return ctx.namespace.alloc(&&value);

      case method:
        return &ctx.values.push_back(&&value);
    }
  }

  context(namespace mut &namespace)
    : namespace(&namespace)
  {
    text.reserve(32);
    stack.reserve(256);
    targets.reserve(16);
    blocks.reserve(8);
    blocks.resize(1);
  }

  ~context() = default;
}

fn is_root(context &ctx, operand &path) -> bool
{
  return path.name[0] == cast('\\') && path.name[1] == 0;
}

fn is_qualified(context &ctx, operand &path) -> bool
{
  return path.name.len != 4;
}

fn resolve(context &ctx, operand mut &path) -> std::optional<acpi::node *>
{
  var i = 0;
  var name = path.name;
  var node = ctx.scope;

  switch (name[i])
  {
    case '\\':
      node = ctx.namespace.root;
      ++i;

    case '^':
      for (; name[i] == cast('^'); ++i)
      {
        if (!node.parent)
          return None;

        node = node.parent;
      }
  }

  switch (name[i])
  {
    case op::zero_op:
      i += 1;

    case op::dualname_prefix:
      i += 1;

    case op::multiname_prefix:
      i += 2;
  }

  for (; i + 4 < name.len; i += 4)
  {
    switch (node.find(name[i .. i + 4]))
    {
      case Some[scope]:
        node = scope;

      else:
        return None;
    }
  }

  path = operand::span(name[i .. name.len]);

  return node;
}

fn lookup(context &ctx, std::span<u8> &name) -> std::optional<acpi::value *>
{
  var i = 0;
  var node = ctx.scope;

  switch (name[i])
  {
    case '\\':
      node = ctx.namespace.root;
      ++i;

    case '^':
      for (; name[i] == cast('^'); ++i)
      {
        if (!node.parent)
          return None;

        node = node.parent;
      }

    case '_':
    case 'A' ..= 'Z':

      for (; node; node = node.parent)
      {
        if (var value = node.get(name); value.is_some)
          return value;
      }

      return None;
  }

  switch (name[i])
  {
    case op::zero_op:
      i += 1;

    case op::dualname_prefix:
      i += 1;

    case op::multiname_prefix:
      i += 2;
  }

  for (; i + 4 < name.len; i += 4)
  {
    switch (node.find(name[i .. i + 4]))
    {
      case Some[scope]:
        node = scope;

      else:
        return None;
    }
  }

  if (var value = node.get(name[i .. name.len]); value.is_some)
    return value;

  return None;
}

fn stream_start(context mut &ctx, std::span<u8> mut &is) -> result
{
  ctx.push_state(state::end);
  ctx.push_state(state::term_list);

  return ok;
}

fn pkg_length(context mut &ctx, std::span<u8> mut &is) -> result
{
  var len = 0;
  var beg = is.data;

  if (!scan_pkg_length(&mut is, &mut len))
    return unexpected_end_of_stream;

  var pkg = cast<usize>(len) - (is.data - beg);

  ctx.blocks.push_back(is.front_n(pkg), is.drop_front(pkg));

  is.take_front!(pkg);

  return ok;
}

fn byte_data(context mut &ctx, std::span<u8> mut &is) -> result
{
  var byte = 0;

  if (!scan_byte_data(&mut is, &mut byte))
    return unexpected_end_of_stream;

  ctx.push_operand(operand::byte(byte));

  return ok;
}

fn word_data(context mut &ctx, std::span<u8> mut &is) -> result
{
  var word = 0;

  if (!scan_word_data(&mut is, &mut word))
    return unexpected_end_of_stream;

  ctx.push_operand(operand::word(word));

  return ok;
}

fn dword_data(context mut &ctx, std::span<u8> mut &is) -> result
{
  var dword = 0;

  if (!scan_dword_data(&mut is, &mut dword))
    return unexpected_end_of_stream;

  ctx.push_operand(operand::dword(dword));

  return ok;
}

fn qword_data(context mut &ctx, std::span<u8> mut &is) -> result
{
  var qword = 0;

  if (!scan_qword_data(&mut is, &mut qword))
    return unexpected_end_of_stream;

  ctx.push_operand(operand::qword(qword));

  return ok;
}

fn name_string(context mut &ctx, std::span<u8> mut &is) -> result
{
  var name = std::span<u8>();

  if (!scan_name_string(&mut is, &mut name))
    return unexpected_end_of_stream;

  ctx.push_operand(operand::name(name));

  return ok;
}

fn obj_string(context mut &ctx, std::span<u8> mut &is) -> result
{
  var name = std::span<u8>();

  if (!scan_name_string(&mut is, &mut name))
    return unexpected_end_of_stream;

  ctx.push_value(value(name_to_string(name)));

  return ok;
}

fn load(context mut &ctx, operand mut &operand) -> result
{
  while (operand.is_reference)
  {
    switch (operand.reference)
    {
      case local[idx]:
        operand = ctx.stack[idx];

      case value[var dst = operand.reference.value]:
        operand = operand::value();

        if (var rc = ctx.namespace.load(dst, &mut operand.value); !rc)
          return rc;

      case index[var index = operand.reference.index]:
        operand = operand::value();

        if (var rc = ctx.namespace.load(index.0, index.1, &mut operand.value); !rc)
          return rc;
    }
  }

  return ok;
}

fn load(context mut &ctx, target &target, value mut &value) -> result
{
  switch (target)
  {
    case arg[idx]:
      var src = ctx.arg(idx);

      if (var rc = load(&mut ctx, &mut src); !rc)
        return rc;

      value = &move src.value;

    case local[idx]:
      var src = ctx.local(idx);

      if (var rc = load(&mut ctx, &mut src); !rc)
        return rc;

      value = &move src.value;

    case name[name]:
      var obj = lookup(ctx, name);

      if (!obj)
        return name_not_found;

      if (var rc = ctx.namespace.load(obj?!, &mut value); !rc)
        return rc;

    case reference[reference]:
      switch (reference)
      {
        case local[idx]:
          var src = ctx.stack[idx];

          if (var rc = load(&mut ctx, &mut src); !rc)
            return rc;

          value = &move src.value;

        case value[dst]:
          if (var rc = ctx.namespace.load(dst, &mut value); !rc)
            return rc;

        case index[index]:
          if (var rc = ctx.namespace.load(index.0, index.1, &mut value); !rc)
            return rc;
      }

    else:
      return invalid_target;
  }

  return ok;
}

fn arg_obj(context mut &ctx, std::span<u8> mut &is) -> result
{
  switch (var op = peek_op(is))
  {
    case arg0_op:
    case arg1_op:
    case arg2_op:
    case arg3_op:
    case arg4_op:
    case arg5_op:
    case arg6_op:
      is.drop_front!(1);
      ctx.push_reference(ctx.arg(cast<usize>(op) - 0x68));

    else:
      return invalid_opcode;
  }

  return ok;
}

fn local_obj(context mut &ctx, std::span<u8> mut &is) -> result
{
  switch (var op = peek_op(is))
  {
    case local0_op:
    case local1_op:
    case local2_op:
    case local3_op:
    case local4_op:
    case local5_op:
    case local6_op:
    case local7_op:
      is.drop_front!(1);
      ctx.push_reference(ctx.local(cast<usize>(op) - 0x60));

    else:
      return invalid_opcode;
  }

  return ok;
}

fn data_object(context mut &ctx, std::span<u8> mut &is) -> result
{
  switch (peek_op(is))
  {
    case byte_prefix:
      is.drop_front!(1);

      var byte = 0;

      if (!scan_byte_data(&mut is, &mut byte))
        return unexpected_end_of_stream;

      ctx.push_value(value(byte));

    case word_prefix:
      is.drop_front!(1);

      var word = 0;

      if (!scan_word_data(&mut is, &mut word))
        return unexpected_end_of_stream;

      ctx.push_value(value(word));

    case dword_prefix:
      is.drop_front!(1);

      var dword = 0;

      if (!scan_dword_data(&mut is, &mut dword))
        return unexpected_end_of_stream;

      ctx.push_value(value(dword));

    case string_prefix:
      is.drop_front!(1);

      var string = std::string();

      if (!scan_string_data(&mut is, &mut string))
        return unexpected_end_of_stream;

      ctx.push_value(value(&move string));

    case qword_prefix:
      is.drop_front!(1);

      var qword = 0;

      if (!scan_qword_data(&mut is, &mut qword))
        return unexpected_end_of_stream;

      ctx.push_value(value(qword));

    case zero_op:
      is.drop_front!(1);
      ctx.push_value(value::integer(0));

    case one_op:
      is.drop_front!(1);
      ctx.push_value(value::integer(1));

    case ones_op:
      is.drop_front!(1);
      ctx.push_value(value::integer(~0));

    case revision_op:
      is.drop_front!(2);
      ctx.push_value(value::integer(0));

    else:
      return invalid_prefix;
  }

  return ok;
}

fn num_elements(context mut &ctx, std::span<u8> mut &is) -> result
{
  var size = 0;

  switch (ctx.stack.take_back())
  {
    case byte[byte]:
      size = cast<usize>(byte);

    case value[value]:
      if (!ctx.namespace.to_integer(&mut value))
        return bad_value;

     size = cast<usize>(value.integer);
  }

  ctx.push_value(value::package(size));

  return ok;
}

fn package_element_list(context mut &ctx, std::span<u8> mut &is) -> result
{
  switch (peek_op(is))
  {
    case stream_end:
      ;

    case byte_prefix:
    case word_prefix:
    case dword_prefix:
    case string_prefix:
    case qword_prefix:
    case zero_op:
    case one_op:
    case ones_op:
    case revision_op:
      ctx.push_state(state::package_element_list);
      ctx.push_state(state::package_element);
      ctx.push_state(state::term_arg);

    case package_op:
    case varpackage_op:
      ctx.push_state(state::package_element_list);
      ctx.push_state(state::package_element);
      ctx.push_state(state::term_arg);

    case buffer_op:
      ctx.push_state(state::package_element_list);
      ctx.push_state(state::package_element);
      ctx.push_state(state::term_arg);

    case root_char:
    case under_char:
    case parent_prefix_char:
    case dualname_prefix:
    case multiname_prefix:
    case alpha_char_a ..= alpha_char_z:
      ctx.push_state(state::package_element_list);
      ctx.push_state(state::package_element);
      ctx.push_state(state::obj_string);

    else:
      return invalid_opcode;
  }

  return ok;
}

fn package_element(context mut &ctx, std::span<u8> mut &is) -> result
{
  var element = ctx.stack.take_back().value;
  var mut &package = ctx.stack.back.value.package;

  package.elements.push_back(&move element);

  return ok;
}

fn package(context mut &ctx, std::span<u8> mut &is) -> result
{
  ctx.stack.back.value.package.elements.resize(ctx.stack.back.value.package.size);

  return ok;
}

fn buffer(context mut &ctx, std::span<u8> mut &is) -> result
{
  var size = ctx.stack.take_back().value;

  if (!size.is_integer)
    return bad_value;

  if (size.integer < cast(is.len))
    return bad_value;

  ctx.push_value(value::buffer(cast<usize>(size.integer), is));

  ctx.stack.back.value.buffer.bytes.resize(ctx.stack.back.value.buffer.size);

  return ok;
}

fn target(context mut &ctx, std::span<u8> mut &is) -> result
{
  switch (var op = peek_op(is))
  {
    case zero_op:
      is.drop_front!(1);
      ctx.targets.push_back(target::nul());

    case arg0_op:
    case arg1_op:
    case arg2_op:
    case arg3_op:
    case arg4_op:
    case arg5_op:
    case arg6_op:
      is.drop_front!(1);
      ctx.targets.push_back(target::arg(cast<usize>(op) - 0x68));

    case local0_op:
    case local1_op:
    case local2_op:
    case local3_op:
    case local4_op:
    case local5_op:
    case local6_op:
    case local7_op:
      is.drop_front!(1);
      ctx.targets.push_back(target::local(cast<usize>(op) - 0x60));

    case debug_op:
      is.drop_front!(2);
      ctx.targets.push_back(target::debug());

    case root_char:
    case under_char:
    case parent_prefix_char:
    case dualname_prefix:
    case multiname_prefix:
    case alpha_char_a ..= alpha_char_z:

      var name = std::span<u8>();

      if (!scan_name_string(&mut is, &mut name))
        return unexpected_end_of_stream;

      ctx.targets.push_back(target::name(name));

    case refof_op:
      ctx.push_state(state::target_refof);
      ctx.push_state(state::term_arg);

    case index_op:
      ctx.push_state(state::target_refof);
      ctx.push_state(state::term_arg);

    case derefof_op:
      ctx.push_state(state::target_derefof);
      ctx.push_state(state::term_arg);

    else:
      return invalid_opcode;
  }

  return ok;
}

fn target_refof(context mut &ctx, std::span<u8> mut &is) -> result
{
  ctx.targets.push_back(target::reference(ctx.stack.take_back().value.reference));

  return ok;
}

fn target_derefof(context mut &ctx, std::span<u8> mut &is) -> result
{
  ctx.targets.push_back(target::reference(ctx.stack.take_back().reference));

  return ok;
}

fn term_arg(context mut &ctx, std::span<u8> mut &is) -> result
{
  switch (peek_op(is))
  {
    case arg0_op:
    case arg1_op:
    case arg2_op:
    case arg3_op:
    case arg4_op:
    case arg5_op:
    case arg6_op:

      if (var rc = arg_obj(&mut ctx, &mut is); !rc)
        return rc;

    case local0_op:
    case local1_op:
    case local2_op:
    case local3_op:
    case local4_op:
    case local5_op:
    case local6_op:
    case local7_op:

      if (var rc = local_obj(&mut ctx, &mut is); !rc)
        return rc;

    case byte_prefix:
    case word_prefix:
    case dword_prefix:
    case string_prefix:
    case qword_prefix:
    case zero_op:
    case one_op:
    case ones_op:
    case revision_op:

      if (var rc = data_object(&mut ctx, &mut is); !rc)
        return rc;

    case package_op:
      is.drop_front!(1);
      ctx.push_state(state::pkg);
      ctx.push_state(state::package);
      ctx.push_state(state::package_element_list);
      ctx.push_state(state::num_elements);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::pkg_length);

    case varpackage_op:
      is.drop_front!(1);
      ctx.push_state(state::pkg);
      ctx.push_state(state::package);
      ctx.push_state(state::package_element_list);
      ctx.push_state(state::num_elements);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::pkg_length);

    case buffer_op:
      is.drop_front!(1);
      ctx.push_state(state::pkg);
      ctx.push_state(state::buffer);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::pkg_length);

    case l_not_op:
      is.drop_front!(1);
      ctx.push_state(state::l_not_op);
      ctx.push_state(state::term_arg);

    case l_and_op:
      is.drop_front!(1);
      ctx.push_state(state::l_and_op);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case l_or_op:
      is.drop_front!(1);
      ctx.push_state(state::l_or_op);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case l_equal_op:
      is.drop_front!(1);
      ctx.push_state(state::l_equal_op);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case l_greater_op:
      is.drop_front!(1);
      ctx.push_state(state::l_greater_op);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case l_less_op:
      is.drop_front!(1);
      ctx.push_state(state::l_less_op);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case not_op:
      is.drop_front!(1);
      ctx.push_state(state::not_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);

    case and_op:
      is.drop_front!(1);
      ctx.push_state(state::and_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case nand_op:
      is.drop_front!(1);
      ctx.push_state(state::nand_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case or_op:
      is.drop_front!(1);
      ctx.push_state(state::or_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case nor_op:
      is.drop_front!(1);
      ctx.push_state(state::nor_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case xor_op:
      is.drop_front!(1);
      ctx.push_state(state::xor_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case add_op:
      is.drop_front!(1);
      ctx.push_state(state::add_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case subtract_op:
      is.drop_front!(1);
      ctx.push_state(state::subtract_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case multiply_op:
      is.drop_front!(1);
      ctx.push_state(state::multiply_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case divide_op:
      is.drop_front!(1);
      ctx.push_state(state::divide_op);
      ctx.push_state(state::target);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case mod_op:
      is.drop_front!(1);
      ctx.push_state(state::mod_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case shiftleft_op:
      is.drop_front!(1);
      ctx.push_state(state::shiftleft_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case shiftright_op:
      is.drop_front!(1);
      ctx.push_state(state::shiftright_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case increment_op:
      is.drop_front!(1);
      ctx.push_state(state::increment_op);
      ctx.push_state(state::target);

    case decrement_op:
      is.drop_front!(1);
      ctx.push_state(state::decrement_op);
      ctx.push_state(state::target);

    case refof_op:
      is.drop_front!(1);
      ctx.push_state(state::refof_op);
      ctx.push_state(state::target);

    case condrefof_op:
      is.drop_front!(2);
      ctx.push_state(state::condrefof_op);
      ctx.push_state(state::target);
      ctx.push_state(state::target);

    case index_op:
      is.drop_front!(1);
      ctx.push_state(state::index_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case derefof_op:
      is.drop_front!(1);
      ctx.push_state(state::derefof_op);
      ctx.push_state(state::term_arg);

    case match_op:
      is.drop_front!(1);
      ctx.push_state(state::match_op);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::term_arg);

    case mid_op:
      is.drop_front!(1);
      ctx.push_state(state::mid_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case concat_op:
      is.drop_front!(1);
      ctx.push_state(state::concat_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case tobuffer_op:
      is.drop_front!(1);
      ctx.push_state(state::to_buffer);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);

    case todecimalstring_op:
      is.drop_front!(1);
      ctx.push_state(state::to_decimalstring);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);

    case tohexstring_op:
      is.drop_front!(1);
      ctx.push_state(state::to_hexstring);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);

    case tointeger_op:
      is.drop_front!(1);
      ctx.push_state(state::to_integer);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);

    case sizeof_op:
      is.drop_front!(1);
      ctx.push_state(state::sizeof_op);
      ctx.push_state(state::term_arg);

    case timer_op:
      is.drop_front!(2);
      ctx.push_state(state::timer_op);

    case acquire_op:
      is.drop_front!(2);
      ctx.push_state(state::acquire_op);
      ctx.push_state(state::word_data);
      ctx.push_state(state::term_arg);

    case load_op:
      is.drop_front!(2);
      ctx.push_state(state::load_op);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);

    case store_op:
    case copyobject_op:
      is.drop_front!(1);
      ctx.push_state(state::store);
      ctx.push_state(state::target);
      ctx.push_state(state::term_arg);

    case root_char:
    case under_char:
    case parent_prefix_char:
    case dualname_prefix:
    case multiname_prefix:
    case alpha_char_a ..= alpha_char_z:
      ctx.push_state(state::method_invocation);
      ctx.push_state(state::name_string);

    else:
      return invalid_opcode;
  }

  return ok;
}

fn term_list(context mut &ctx, std::span<u8> mut &is) -> result
{
  switch (peek_op(is))
  {
    case stream_end:
      ;

    case name_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::define_name);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::name_string);

    case alias_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::define_alias);
      ctx.push_state(state::name_string);
      ctx.push_state(state::name_string);

    case scope_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::pkg);
      ctx.push_state(state::end_scope);
      ctx.push_state(state::term_list);
      ctx.push_state(state::define_scope);
      ctx.push_state(state::name_string);
      ctx.push_state(state::pkg_length);

    case device_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::pkg);
      ctx.push_state(state::end_scope);
      ctx.push_state(state::term_list);
      ctx.push_state(state::define_device);
      ctx.push_state(state::name_string);
      ctx.push_state(state::pkg_length);

    case processor_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::pkg);
      ctx.push_state(state::end_scope);
      ctx.push_state(state::term_list);
      ctx.push_state(state::define_processor);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::dword_data);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::name_string);
      ctx.push_state(state::pkg_length);

    case powerres_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::pkg);
      ctx.push_state(state::end_scope);
      ctx.push_state(state::term_list);
      ctx.push_state(state::define_powerres);
      ctx.push_state(state::word_data);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::name_string);
      ctx.push_state(state::pkg_length);

    case thermalzone_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::pkg);
      ctx.push_state(state::end_scope);
      ctx.push_state(state::term_list);
      ctx.push_state(state::define_thermalzone);
      ctx.push_state(state::name_string);
      ctx.push_state(state::pkg_length);

    case method_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::pkg);
      ctx.push_state(state::define_method);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::name_string);
      ctx.push_state(state::pkg_length);

    case mutex_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::define_mutex);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::name_string);

    case event_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::define_event);
      ctx.push_state(state::name_string);

    case field_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::pkg);
      ctx.push_state(state::define_field);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::name_string);
      ctx.push_state(state::pkg_length);

    case indexfield_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::pkg);
      ctx.push_state(state::define_indexfield);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::name_string);
      ctx.push_state(state::name_string);
      ctx.push_state(state::pkg_length);

    case bankfield_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::pkg);
      ctx.push_state(state::define_bankfield);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::name_string);
      ctx.push_state(state::name_string);
      ctx.push_state(state::pkg_length);

    case opregion_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::define_opregion);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::byte_data);
      ctx.push_state(state::name_string);

    case createfield_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::create_field);
      ctx.push_state(state::name_string);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case createbitfield_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::create_bit_field);
      ctx.push_state(state::name_string);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case createbytefield_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::create_byte_field);
      ctx.push_state(state::name_string);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case createwordfield_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::create_word_field);
      ctx.push_state(state::name_string);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case createdwordfield_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::create_dword_field);
      ctx.push_state(state::name_string);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case createqwordfield_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::create_qword_field);
      ctx.push_state(state::name_string);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::term_arg);

    case release_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::release_op);
      ctx.push_state(state::term_arg);

    case stall_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::stall_op);
      ctx.push_state(state::term_arg);

    case sleep_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::sleep_op);
      ctx.push_state(state::term_arg);

    case fatal_op:
      is.drop_front!(2);
      ctx.push_state(state::term_list);
      ctx.push_state(state::fatal_op);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::dword_data);
      ctx.push_state(state::byte_data);

    case breakpoint_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);

    case if_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::if_op);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::pkg_length);

    case else_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::pkg);
      ctx.push_state(state::pkg_length);

    case while_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::pkg);
      ctx.push_state(state::while_op);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::pkg_length);

    case break_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::break_op);

    case continue_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::continue_op);

    case notify_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);
      ctx.push_state(state::notify_op);
      ctx.push_state(state::term_arg);
      ctx.push_state(state::name_string);

    case package_op:
    case varpackage_op:
      is.drop_front!(1);
      ctx.push_state(state::pkg);
      ctx.push_state(state::pkg_length);

    case zero_op:
    case one_op:
    case ones_op:
    case root_char:
    case under_char:
    case parent_prefix_char:
    case dualname_prefix:
    case multiname_prefix:
    case alpha_char_a ..= alpha_char_z:
    case not_op:
    case add_op:
    case subtract_op:
    case multiply_op:
    case divide_op:
    case mod_op:
    case shiftleft_op:
    case shiftright_op:
    case and_op:
    case nand_op:
    case or_op:
    case nor_op:
    case xor_op:
    case increment_op:
    case decrement_op:
    case index_op:
    case derefof_op:
    case match_op:
    case tobuffer_op:
    case todecimalstring_op:
    case tohexstring_op:
    case tointeger_op:
    case acquire_op:
    case load_op:
    case store_op:
    case copyobject_op:
      ctx.push_state(state::term_list);
      ctx.push_state(state::pop);

      if (var rc = term_arg(&mut ctx, &mut is); !rc)
        return rc;

    case return_op:
      is.drop_front!(1);
      ctx.push_state(state::return_op);
      ctx.push_state(state::term_arg);

    case noop_op:
      is.drop_front!(1);
      ctx.push_state(state::term_list);

    else:
      return invalid_opcode;
  }

  return ok;
}

fn define(context mut &ctx, acpi::node *scope, std::span<u8> name, value *value) -> result
{
  if (ctx.scope.type == acpi::node::type::method && scope != ctx.frame.scope)
    return invalid_path;

  ctx.namespace.define(scope, name, value);

  return ok;
}

fn define(context mut &ctx, acpi::node *scope, std::span<u8> name, value &&value) -> result
{
  if (ctx.scope.type == acpi::node::type::method && scope != ctx.frame.scope)
    return invalid_path;

  ctx.namespace.define(scope, name, ctx.alloc(&move value));

  return ok;
}

#[noinline]
fn define_name(context mut &ctx, std::span<u8> mut &is) -> result
{
  var src = ctx.stack.take_back();
  var name = ctx.stack.take_back();

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:

      if (var rc = define(&mut ctx, node, name.span, &move src.value); !rc)
        return rc;

    else:
      return invalid_path;
  }

  return ok;
}

#[noinline]
fn define_alias(context mut &ctx, std::span<u8> mut &is) -> result
{
  var name = ctx.stack.take_back();
  var target = ctx.stack.take_back().name;

  if (var obj = lookup(ctx, target))
  {
    switch (resolve(ctx, &mut name))
    {
      case Some[node]:

        if (var rc = define(&mut ctx, node, name.span, obj?!); !rc)
          return rc;

      else:
        return invalid_path;
    }
  }

  return ok;
}

#[noinline]
fn define_scope(context mut &ctx, std::span<u8> mut &is) -> result
{
  var name = ctx.stack.take_back();

  if (ctx.scope.type == acpi::node::type::method)
    return invalid_target;

  if (!is_root(ctx, name))
  {
    switch (resolve(ctx, &mut name))
    {
      case Some[node]:

        var scope = node.find(name.span);

        if (!scope)
          scope = ctx.namespace.define(node, acpi::node::type::scope, name.span);

        ctx.push_scope(scope?!);

      else:
        return invalid_path;
    }
  }
  else
  {
    ctx.push_scope(ctx.namespace.root);
  }

  return ok;
}

#[noinline]
fn define_device(context mut &ctx, std::span<u8> mut &is) -> result
{
  var name = ctx.stack.take_back();

  if (ctx.scope.type == acpi::node::type::method)
    return invalid_target;

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:
      var scope = ctx.namespace.define(node, acpi::node::type::device, name.span);

      ctx.push_scope(scope);

    else:
      return invalid_path;
  }

  return ok;
}

#[noinline]
fn define_processor(context mut &ctx, std::span<u8> mut &is) -> result
{
  var pblklen = ctx.stack.take_back().byte;
  var pblkaddr = ctx.stack.take_back().dword;
  var procid = ctx.stack.take_back().byte;
  var name = ctx.stack.take_back();

  if (ctx.scope.type == acpi::node::type::method)
    return invalid_target;

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:
      var scope = ctx.namespace.define(node, acpi::node::type::processor, name.span);

      ctx.push_scope(scope);

    else:
      return invalid_path;
  }

  return ok;
}

#[noinline]
fn define_powerres(context mut &ctx, std::span<u8> mut &is) -> result
{
  var resource_order = ctx.stack.take_back().word;
  var system_level = ctx.stack.take_back().byte;
  var name = ctx.stack.take_back();

  if (ctx.scope.type == acpi::node::type::method)
    return invalid_target;

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:
      var scope = ctx.namespace.define(node, acpi::node::type::power_resource, name.span);

      ctx.push_scope(scope);

    else:
      return invalid_path;
  }

  return ok;
}

#[noinline]
fn define_thermalzone(context mut &ctx, std::span<u8> mut &is) -> result
{
  var name = ctx.stack.take_back();

  if (ctx.scope.type == acpi::node::type::method)
    return invalid_target;

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:
      var scope = ctx.namespace.define(node, acpi::node::type::thermal_zone, name.span);

      ctx.push_scope(scope);

    else:
      return invalid_path;
  }

  return ok;
}

fn named_field(context mut &ctx, value *source, u8 mut &flags, u64 mut &offset, std::span<u8> mut &is) -> result
{
  var name = operand::name();

  if (!scan_name_string(&mut is, &mut name.name))
    return unexpected_end_of_stream;

  var length = 0;

  if (!scan_pkg_length(&mut is, &mut length))
    return unexpected_end_of_stream;

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:

      if (var rc = define(&mut ctx, node, name.span, value::field(acpi::reference(source), flags, offset, length)); !rc)
        return rc;

    else:
      return invalid_path;
  }

  offset += length;

  return ok;
}

fn reserved_field(context mut &ctx, u8 mut &flags, u64 mut &offset, std::span<u8> mut &is) -> result
{
  var length = 0;

  if (!scan_pkg_length(&mut is, &mut length))
    return unexpected_end_of_stream;

  offset += length;

  return ok;
}

fn access_field(context mut &ctx, u8 mut &flags, u64 mut &offset, std::span<u8> mut &is) -> result
{
  var type = 0;

  if (!scan_byte_data(&mut is, &mut type))
    return unexpected_end_of_stream;

  var attrib = 0;

  if (!scan_byte_data(&mut is, &mut attrib))
    return unexpected_end_of_stream;

  flags = type;

  return ok;
}

fn connect_field(context mut &ctx, u8 mut &flags, u64 mut &offset, std::span<u8> mut &is) -> result
{
  switch (peek_op(is))
  {
    case buffer_op:
      is.drop_front!(1);

      var len = 0;
      var beg = is.data;

      if (!scan_pkg_length(&mut is, &mut len))
        return unexpected_end_of_stream;

      is.drop_front!(cast<usize>(len) - (is.data - beg));

    case under_char:
    case alpha_char_a ..= alpha_char_z:

      var name = std::span<u8>();

      if (!scan_name_string(&mut is, &mut name))
        return unexpected_end_of_stream;

    else:
      return invalid_opcode;
  }

  return ok;
}

fn extended_access_field(context mut &ctx, u8 mut &flags, u64 mut &offset, std::span<u8> mut &is) -> result
{
  var type = 0;

  if (!scan_byte_data(&mut is, &mut type))
    return unexpected_end_of_stream;

  var attrib = 0;

  if (!scan_byte_data(&mut is, &mut attrib))
    return unexpected_end_of_stream;

  var length = 0;

  if (!scan_byte_data(&mut is, &mut length))
    return unexpected_end_of_stream;

  flags = type;

  return ok;
}

#[noinline]
fn define_field(context mut &ctx, std::span<u8> mut &is) -> result
{
  var flags = ctx.stack.take_back().byte;
  var name = ctx.stack.take_back().name;

  var offset = 0;

  var source = lookup(ctx, name);

  if (!source || !source.value.is_opregion)
    return name_not_found;

  while (!is.empty)
  {
    switch (peek_op(is))
    {
      case zero_op:
        is.drop_front!(1);

        if (var rc = reserved_field(&mut ctx, &mut flags, &mut offset, &mut is); !rc)
          return rc;

      case one_op:
        is.drop_front!(1);

        if (var rc = access_field(&mut ctx, &mut flags, &mut offset, &mut is); !rc)
          return rc;

      case cast<op>(0x02):
        is.drop_front!(1);

        if (var rc = connect_field(&mut ctx, &mut flags, &mut offset, &mut is); !rc)
          return rc;

      case cast<op>(0x03):
        is.drop_front!(1);

        if (var rc = extended_access_field(&mut ctx, &mut flags, &mut offset, &mut is); !rc)
          return rc;

      case under_char:
      case alpha_char_a ..= alpha_char_z:

        if (var rc = named_field(&mut ctx, source?!, &mut flags, &mut offset, &mut is); !rc)
          return rc;

      else:
        return invalid_opcode;
    }
  }

  return ok;
}

#[noinline]
fn define_bankfield(context mut &ctx, std::span<u8> mut &is) -> result
{
  var flags = ctx.stack.take_back().byte;
  var bank_value = ctx.stack.take_back();
  var bank_name = ctx.stack.take_back().name;
  var region_name = ctx.stack.take_back().name;

  var offset = 0;

  var region = lookup(ctx, region_name);

  if (!region || !region.value.is_opregion)
    return name_not_found;

  var bank = lookup(ctx, bank_name);

  if (!bank || !bank.value.is_field)
    return name_not_found;

  if (var rc = load(&mut ctx, &mut bank_value); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut bank_value.value))
    return bad_value;

  var source = ctx.alloc(value::bankedregion(region?!, bank?!, bank_value.value.integer));

  while (!is.empty)
  {
    switch (peek_op(is))
    {
      case zero_op:
        is.drop_front!(1);

        if (var rc = reserved_field(&mut ctx, &mut flags, &mut offset, &mut is); !rc)
          return rc;

      case one_op:
        is.drop_front!(1);

        if (var rc = access_field(&mut ctx, &mut flags, &mut offset, &mut is); !rc)
          return rc;

      case under_char:
      case alpha_char_a ..= alpha_char_z:

        if (var rc = named_field(&mut ctx, source, &mut flags, &mut offset, &mut is); !rc)
          return rc;

      else:
        return invalid_opcode;
    }
  }

  return ok;
}

#[noinline]
fn define_indexfield(context mut &ctx, std::span<u8> mut &is) -> result
{
  var flags = ctx.stack.take_back().byte;
  var data_name = ctx.stack.take_back().name;
  var index_name = ctx.stack.take_back().name;

  var offset = 0;

  var data = lookup(ctx, data_name);

  if (!data || !data.value.is_field)
    return name_not_found;

  var index = lookup(ctx, index_name);

  if (!index || !index.value.is_field)
    return name_not_found;

  var source = ctx.alloc(value::indexedregion(data?!, index?!));

  while (!is.empty)
  {
    switch (peek_op(is))
    {
      case zero_op:
        is.drop_front!(1);

        if (var rc = reserved_field(&mut ctx, &mut flags, &mut offset, &mut is); !rc)
          return rc;

      case one_op:
        is.drop_front!(1);

        if (var rc = access_field(&mut ctx, &mut flags, &mut offset, &mut is); !rc)
          return rc;

      case under_char:
      case alpha_char_a ..= alpha_char_z:

        if (var rc = named_field(&mut ctx, source, &mut flags, &mut offset, &mut is); !rc)
        return rc;

      else:
        return invalid_opcode;
    }
  }

  return ok;
}

#[noinline]
fn define_opregion(context mut &ctx, std::span<u8> mut &is) -> result
{
  var length  = ctx.stack.take_back();
  var offset = ctx.stack.take_back();
  var space = ctx.stack.take_back().byte;
  var name = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut length); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut length.value))
    return bad_value;

  if (var rc = load(&mut ctx, &mut offset); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut offset.value))
    return bad_value;

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:

      if (var rc = define(&mut ctx, node, name.span, value::opregion(node, space, offset.value.integer, length.value.integer)); !rc)
        return rc;

    else:
      return invalid_path;
  }

  return ok;
}

#[noinline]
fn define_method(context mut &ctx, std::span<u8> mut &is) -> result
{
  var flags = ctx.stack.take_back().byte;
  var name = ctx.stack.take_back();

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:

      if (var rc = define(&mut ctx, node, name.span, value::method(node, flags, is)); !rc)
        return rc;

    else:
      return invalid_path;
  }

  return ok;
}

#[noinline]
fn define_mutex(context mut &ctx, std::span<u8> mut &is) -> result
{
  var flags = ctx.stack.take_back().byte;
  var name = ctx.stack.take_back();

  if (ctx.scope.type == acpi::node::type::method)
    return invalid_target;

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:
      var mutex = acpi::mutex();

      if (var rc = ctx.namespace.create_mutex(flags, &mut mutex); !rc)
        return rc;

      ctx.namespace.define(node, name.span, value::mutex(mutex));

    else:
      return invalid_path;
  }

  return ok;
}

#[noinline]
fn define_event(context mut &ctx, std::span<u8> mut &is) -> result
{
  var name = ctx.stack.take_back();

  if (ctx.scope.type == acpi::node::type::method)
    return invalid_target;

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:
      ctx.namespace.define(node, name.span, value::event());

    else:
      return invalid_path;
  }

  return ok;
}

#[noinline]
fn create_field(context mut &ctx, std::span<u8> mut &is) -> result
{
  var name = ctx.stack.take_back();

  var offset = 0;
  var length = 0;

  switch (ctx.state)
  {
    case create_field:

      var numbits = ctx.stack.take_back().value;
      var bitindex = ctx.stack.take_back().value;

      if (!ctx.namespace.to_integer(&mut numbits))
        return bad_value;

      if (!ctx.namespace.to_integer(&mut bitindex))
        return bad_value;

      offset = bitindex.integer;
      length = numbits.integer;

    case create_bit_field:

      var bitindex = ctx.stack.take_back().value;

      if (!ctx.namespace.to_integer(&mut bitindex))
        return bad_value;

      offset = bitindex.integer;
      length = 1;

    case create_byte_field:

      var byteindex = ctx.stack.take_back().value;

      if (!ctx.namespace.to_integer(&mut byteindex))
        return bad_value;

      offset = byteindex.integer * 8;
      length = 8;

    case create_word_field:

      var byteindex = ctx.stack.take_back().value;

      if (!ctx.namespace.to_integer(&mut byteindex))
        return bad_value;

      offset = byteindex.integer * 8;
      length = 16;

    case create_dword_field:

      var byteindex = ctx.stack.take_back().value;

      if (!ctx.namespace.to_integer(&mut byteindex))
        return bad_value;

      offset = byteindex.integer * 8;
      length = 32;

    case create_qword_field:

      var byteindex = ctx.stack.take_back().value;

      if (!ctx.namespace.to_integer(&mut byteindex))
        return bad_value;

      offset = byteindex.integer * 8;
      length = 64;
  }

  var sourcebuff = ctx.stack.take_back();

  if (!sourcebuff.is_reference)
    return invalid_target;

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:

      if (var rc = define(&mut ctx, node, name.span, value::field(sourcebuff.reference, 0, offset, length)); !rc)
        return rc;

    else:
      return invalid_path;
  }

  return ok;
}

#[noinline]
fn unary_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var lhs = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut lhs); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut lhs.value))
    return bad_value;

  switch (ctx.state)
  {
    case not_op:
      ctx.push_value(value(~lhs.value.integer));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case l_not_op:
      ctx.push_value(value(lhs.value.integer == 0));

    else:
      std::panic("invalid reduce");
  }

  return ok;
}

#[noinline]
fn compare_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var rhs = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut rhs); !rc)
    return rc;

  var lhs = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut lhs); !rc)
    return rc;

  switch (lhs.value)
  {
    case integer:
    case boolean:
    case field:
      if (!ctx.namespace.to_integer(&mut lhs.value))
        return bad_value;

      if (!ctx.namespace.to_integer(&mut rhs.value))
        return bad_value;

    case string:
      if (!ctx.namespace.to_string(&mut rhs.value))
        return bad_value;

    case buffer:
      if (!ctx.namespace.to_buffer(&mut rhs.value))
        return bad_value;

    else:
      return bad_value;
  }

  switch (ctx.state)
  {
    case l_equal_op:
      ctx.push_value(value(lhs.value == rhs.value));

    case l_greater_op:
      ctx.push_value(value(lhs.value > rhs.value));

    case l_less_op:
      ctx.push_value(value(lhs.value < rhs.value));

    else:
      std::panic("invalid compare");
  }

  return ok;
}

#[noinline]
fn binary_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var rhs = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut rhs); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut rhs.value))
    return bad_value;

  var lhs = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut lhs); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut lhs.value))
    return bad_value;

  switch (ctx.state)
  {
    case add_op:
      ctx.push_value(value(std::add_with_carry(lhs.value.integer, rhs.value.integer).0));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case subtract_op:
      ctx.push_value(value(std::sub_with_borrow(lhs.value.integer, rhs.value.integer).0));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case multiply_op:
      ctx.push_value(value(std::mul_with_carry(lhs.value.integer, rhs.value.integer).0));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case divide_op:
      ctx.push_value(value(rhs.value.integer != 0 ? lhs.value.integer / rhs.value.integer : 0));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

      switch (ctx.targets.back)
      {
        case nul:
          ctx.targets.pop_back();

        else:
          ctx.push_value(value(rhs.value.integer != 0 ? lhs.value.integer % rhs.value.integer : 0));

          if (var rc = store(&mut ctx, &mut is); !rc)
            return rc;

          ctx.stack.pop_back();
      }

    case mod_op:
      ctx.push_value(value(rhs.value.integer != 0 ? lhs.value.integer % rhs.value.integer : 0));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case shiftleft_op:
      ctx.push_value(value(lhs.value.integer << rhs.value.integer));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case shiftright_op:
      ctx.push_value(value(lhs.value.integer >> rhs.value.integer));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case and_op:
      ctx.push_value(value(lhs.value.integer & rhs.value.integer));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case nand_op:
      ctx.push_value(value(~(lhs.value.integer & rhs.value.integer)));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case or_op:
      ctx.push_value(value(lhs.value.integer | rhs.value.integer));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case nor_op:
      ctx.push_value(value(~(lhs.value.integer | rhs.value.integer)));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case xor_op:
      ctx.push_value(value(lhs.value.integer ^ rhs.value.integer));

      if (var rc = store(&mut ctx, &mut is); !rc)
        return rc;

    case l_and_op:
      ctx.push_value(value((lhs.value.integer & rhs.value.integer) != 0));

    case l_or_op:
      ctx.push_value(value((lhs.value.integer | rhs.value.integer) != 0));

    else:
      std::panic("invalid reduce");
  }

  return ok;
}

#[noinline]
fn increment_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var value = value();

  if (var rc = load(&mut ctx, ctx.targets.back, &mut value); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut value))
    return bad_value;

  ctx.push_value(value(value.integer + 1));

  if (var rc = store(&mut ctx, &mut is); !rc)
    return rc;

  return ok;
}

#[noinline]
fn decrement_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var value = value();

  if (var rc = load(&mut ctx, ctx.targets.back, &mut value); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut value))
    return bad_value;

  ctx.push_value(value(value.integer - 1));

  if (var rc = store(&mut ctx, &mut is); !rc)
    return rc;

  return ok;
}

#[noinline]
fn refof_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  switch (ctx.targets.take_back())
  {
    case arg[idx]:
      ctx.push_value(value::reference(ctx.frame.rsp - (NARGS - idx)));

    case local[idx]:
      ctx.push_value(value::reference(ctx.frame.rsp + idx));

    case name[name]:
      var obj = lookup(ctx, name);

      if (!obj)
        return name_not_found;

      ctx.push_value(value::reference(obj?!));

    case reference[reference]:
      ctx.push_value(value::reference(reference));

    else:
      return invalid_target;
  }

  return ok;
}

#[noinline]
fn condrefof_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var dst = ctx.targets.take_back();

  switch (ctx.targets.take_back())
  {
    case arg[idx]:
      ctx.push_value(value::boolean(true));
      ctx.push_value(value::reference(ctx.frame.rsp - (NARGS - idx)));

    case local[idx]:
      ctx.push_value(value::boolean(true));
      ctx.push_value(value::reference(ctx.frame.rsp + idx));

    case name[name]:
      var obj = lookup(ctx, name);

      if (!obj)
      {
        var path = operand::name(name);

        switch (resolve(ctx, &mut path))
        {
          case Some[node]:
            ctx.push_value(value::boolean(!!node.find(path.span)));

          else:
            return invalid_path;
        }

        return ok;
      }

      ctx.push_value(value::boolean(true));
      ctx.push_value(value::reference(obj?!));

    else:
      return invalid_target;
  }

  ctx.targets.push_back(dst);

  if (var rc = store(&mut ctx, &mut is); !rc)
    return rc;

  ctx.stack.pop_back();

  return ok;
}

#[noinline]
fn index_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var index = ctx.stack.take_back();
  var source = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut index); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut index.value))
    return bad_value;

  if (!source.is_reference)
    return invalid_target;

  switch (source.reference)
  {
    case value[value]:
      var indicies = std::vector<usize, N:3>();
      indicies.push_back(cast<usize>(index.value.integer));
      ctx.push_value(value::reference(value, indicies));

    case index[base]:
      var indicies = base.1;
      indicies.push_back(cast<usize>(index.value.integer));
      ctx.push_value(value::reference(base.0, indicies));

    else:
      return invalid_target;
  }

  if (var rc = store(&mut ctx, &mut is); !rc)
    return rc;

  return ok;
}

#[noinline]
fn derefof_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var src = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut src); !rc)
    return rc;

  switch (src.value)
  {
    case string[string]:
      var obj = ctx.namespace.lookup(ctx.scope, string);

      if (!obj)
        return name_not_found;

      ctx.push_operand(operand::reference(obj?!));

    case reference[reference]:
      ctx.push_operand(operand::reference(reference));

    else:
      return invalid_target;
  }

  return ok;
}

fn is_match(u8 op, value &lhs, value &rhs) -> bool
{
  switch (op)
  {
    case 0: // MTR
      return true;

    case 1: // MEQ
      return lhs == rhs;

    case 2: // MLE
      return lhs <= rhs;

    case 3: // MLT
      return lhs < rhs;

    case 4: // MGE
      return lhs >= rhs;

    case 5: // MGT
      return lhs > rhs;
  }

  return false;
}

#[noinline]
fn match_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var start_index = ctx.stack.take_back();
  var value2 = ctx.stack.take_back();
  var op2 = ctx.stack.take_back().byte;
  var value1 = ctx.stack.take_back();
  var op1 = ctx.stack.take_back().byte;
  var search_pkg = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut start_index); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut start_index.value))
    return bad_value;

  if (var rc = load(&mut ctx, &mut value1); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut value1.value))
    return bad_value;

  if (var rc = load(&mut ctx, &mut value2); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut value2.value))
    return bad_value;

  if (var rc = load(&mut ctx, &mut search_pkg); !rc)
    return rc;

  if (!search_pkg.value.is_package)
    return bad_value;

  var result = value::integer(~0);
  var mut &package = search_pkg.value.package;

  for (var idx = cast<usize>(start_index.value.integer); idx < package.elements.len; ++idx)
  {
    if (is_match(op1, package.elements[idx], value1.value) && is_match(op2, package.elements[idx], value2.value))
    {
      result = value(idx);

      break;
    }
  }

  ctx.push_value(result);

  return ok;
}

#[noinline]
fn mid_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var length = ctx.stack.take_back();
  var index = ctx.stack.take_back();
  var src = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut index); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut index.value))
    return bad_value;

  if (var rc = load(&mut ctx, &mut length); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut length.value))
    return bad_value;

  if (var rc = load(&mut ctx, &mut src); !rc)
    return rc;

  var idx = cast<usize>(index.value.integer);
  var len = cast<usize>(length.value.integer);

  switch (src.value)
  {
    case string[string]:
      ctx.push_value(value::string(string.substr(idx, len)));

    case buffer[buffer]:
      ctx.push_value(value::buffer(len, buffer.bytes.subspan(idx, len).span));

    else:
      return bad_value;
  }

  return ok;
}

#[noinline]
fn concat_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var rhs = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut rhs); !rc)
    return rc;

  var lhs = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut lhs); !rc)
    return rc;

  switch (lhs.value)
  {
    case integer:
    case boolean:
      if (!ctx.namespace.to_integer(&mut rhs.value))
        return bad_value;

    case string:
      if (!ctx.namespace.to_string(&mut rhs.value))
        return bad_value;

    case buffer:
      if (!ctx.namespace.to_buffer(&mut rhs.value))
        return bad_value;

    else:
      return bad_value;
  }

  var result = std::string();

  if (!ctx.namespace.to_string(&mut lhs.value))
    return bad_value;

  result.append(lhs.value.string);

  if (!ctx.namespace.to_string(&mut rhs.value))
    return bad_value;

  result.append(rhs.value.string);

  ctx.push_value(value::string(&move result));

  if (var rc = store(&mut ctx, &mut is); !rc)
    return rc;

  return ok;
}

#[noinline]
fn to_buffer(context mut &ctx, std::span<u8> mut &is) -> result
{
  var src = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut src); !rc)
    return rc;

  if (!ctx.namespace.to_buffer(&mut src.value))
    return bad_value;

  ctx.push_value(&move src.value);

  if (var rc = store(&mut ctx, &mut is); !rc)
    return rc;

  return ok;
}

#[noinline]
fn to_decimalstring(context mut &ctx, std::span<u8> mut &is) -> result
{
  var src = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut src); !rc)
    return rc;

  switch (src.value)
  {
    case integer:
    case boolean:
    case field:
      if (!ctx.namespace.to_integer(&mut src.value))
        return bad_value;

      ctx.push_value(value::string(std::format("{}", src.value.integer)));

    case string:
      ctx.push_value(&move src.value);

    else:
      return bad_value;
  }

  if (var rc = store(&mut ctx, &mut is); !rc)
    return rc;

  return ok;
}

#[noinline]
fn to_hexstring(context mut &ctx, std::span<u8> mut &is) -> result
{
  var src = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut src); !rc)
    return rc;

  switch (src.value)
  {
    case integer:
    case boolean:
    case field:
      if (!ctx.namespace.to_integer(&mut src.value))
        return bad_value;

      ctx.push_value(value::string(std::format("{:#x}", src.value.integer)));

    case string:
      ctx.push_value(&move src.value);

    else:
      return bad_value;
  }

  if (var rc = store(&mut ctx, &mut is); !rc)
    return rc;

  return ok;
}

#[noinline]
fn to_integer(context mut &ctx, std::span<u8> mut &is) -> result
{
  var src = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut src); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut src.value))
    return bad_value;

  ctx.push_value(&move src.value);

  if (var rc = store(&mut ctx, &mut is); !rc)
    return rc;

  return ok;
}

#[noinline]
fn sizeof_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var source = ctx.stack.take_back();

  if (source.is_value && source.value.is_reference)
    source = operand::reference(source.value.reference);

  if (!source.is_reference)
    return invalid_target;

  switch (source.reference)
  {
    case value[value]:
      switch (*value)
      {
        case string[string]:
          ctx.push_value(value(string.len));

        case buffer[buffer]:
          ctx.push_value(value(buffer.size));

        case package[package]:
          ctx.push_value(value(package.size));

        else:
          return bad_value;
      }

    case index[index]:
      switch (*index.0)
      {
        case package[package]:
          var package = &package;

          for (var idx : index.1.drop_back(1))
          {
            if (idx >= package.elements.len)
              return bad_access;

            if (!package.elements[idx].is_package)
              return bad_access;

            package = &package.elements[idx].package;
          }

          switch (package.elements[index.1.back])
          {
            case string[string]:
              ctx.push_value(value(string.len));

            case buffer[buffer]:
              ctx.push_value(value(buffer.size));

            case package[package]:
              ctx.push_value(value(package.size));

            else:
              return bad_value;
          }

        else:
          return bad_value;
      }

    else:
      return invalid_target;
  }

  return ok;
}

#[noinline]
fn acquire_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var timeout = ctx.stack.take_back().word;
  var source = ctx.stack.take_back();

  if (!source.is_reference)
    return invalid_target;

  switch (source.reference)
  {
    case value[value]:
      if (!value.is_mutex)
        return bad_value;

      ctx.push_value(value::boolean(!ctx.namespace.try_lock(value.mutex, timeout)));

    else:
      return invalid_target;
  }

  return ok;
}

#[noinline]
fn release_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var source = ctx.stack.take_back();

  if (!source.is_reference)
    return invalid_target;

  switch (source.reference)
  {
    case value[value]:
      if (!value.is_mutex)
        return bad_value;

      ctx.namespace.unlock(value.mutex);

    else:
      return invalid_target;
  }

  return ok;
}

#[noinline]
fn stall_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var period = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut period); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut period.value))
    return bad_value;

  var now = u64();

  if (var rc = ctx.namespace.timer(&mut now); !rc)
    return rc;

  var til = now + 1_000 * period.value.integer;

  while (now < til)
  {
    if (var rc = ctx.namespace.timer(&mut now); !rc)
      return rc;
  }

  return ok;
}

#[noinline]
fn sleep_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var period = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut period); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut period.value))
    return bad_value;

  ctx.namespace.sleep(1_000_000 * period.value.integer);

  return ok;
}

#[noinline]
fn timer_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var now = u64();

  if (var rc = ctx.namespace.timer(&mut now); !rc)
    return rc;

  ctx.push_value(value::integer(now / 100));

  return ok;
}

#[noinline]
fn fatal_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var arg = ctx.stack.take_back();
  var code = ctx.stack.take_back().dword;
  var type = ctx.stack.take_back().byte;

  if (var rc = load(&mut ctx, &mut arg); !rc)
    return rc;

  std::panic("acpi fatal: ", type, " ", code, " ", arg);
}

#[noinline]
fn load_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var src = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut src); !rc)
    return rc;

  if (!ctx.namespace.to_buffer(&mut src.value))
    return bad_value;

  var table = ctx.namespace.alloc(&move src.value);

  if (table.buffer.size < sizeof<acpi::sdt> || cast<acpi::sdt*>(table.buffer.bytes.data).length == 0)
    return invalid_signature;

  var checksum = u8(0);
  for (var ch : table.buffer.bytes)
    checksum = __add_with_carry(checksum, ch).0;

  if (checksum != 0)
    return invalid_checksum;

  ctx.push_frame(0, ctx.scope, is);
  ctx.push_state(state::loaded);
  ctx.push_state(state::pop_frame);
  ctx.push_state(state::end_scope);
  ctx.push_state(state::term_list);
  ctx.push_scope(ctx.namespace.root);

  is = cast<acpi::sdt*>(table.buffer.bytes.data).payload;

  return ok;
}

#[noinline]
fn loaded(context mut &ctx, std::span<u8> mut &is) -> result
{
  ctx.push_value(value::boolean(true));

  if (var rc = store(&mut ctx, &mut is); !rc)
    return rc;

  return ok;
}

#[noinline]
fn return_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  if (var rc = load(&mut ctx, &mut ctx.stack.back); !rc)
    return rc;

  ctx.blocks.resize(ctx.frame.rbp);
  ctx.text.resize(ctx.frame.rip + 1);

  return ok;
}

#[noinline]
fn method_invocation(context mut &ctx, std::span<u8> mut &is) -> result
{
  var obj = lookup(ctx, ctx.stack.take_back().name);

  if (!obj)
    return name_not_found;

  switch (*obj?!)
  {
    case method[method]:
      var argc = cast<usize>(method.flags & 0x7);

      ctx.push_state(state::method_call);

      for (var arg = 0; arg < argc; ++arg)
        ctx.push_state(state::term_arg);

      ctx.push_operand(operand::callee(*obj?!));

    case callback[callback]:
      var argc = cast<usize>(callback.flags & 0x7);

      ctx.push_state(state::method_call);

      for (var arg = 0; arg < argc; ++arg)
        ctx.push_state(state::term_arg);

      ctx.push_operand(operand::callee(*obj?!));

    else:

      ctx.push_operand(operand::reference(obj?!));
  }

  return ok;
}

#[noinline]
fn method_call(context mut &ctx, std::span<u8> mut &is) -> result
{
  var argc = 0;

  while (!ctx.stack[ctx.stack.len - argc - 1].is_callee)
    argc += 1;

  switch (ctx.stack[ctx.stack.len - argc - 1].callee)
  {
    case method[method]:
      ctx.push_frame(argc, method.scope, is);
      ctx.push_state(state::pop_frame);
      ctx.push_state(state::term_list);
      is = method.code;

    case callback[callback]:
      var args = std::vector<value, N:7>();

      for (var i = 0; i < argc; ++i)
        args.push_back(ctx.stack.take_back().value);

      var callback = ctx.stack.take_back().callee.callback;

      var mut &result = ctx.push_value(value());

      if (var rc = callback.callee(&mut ctx.namespace, &mut result, args.span); !rc)
        return rc;
  }

  return ok;
}

#[noinline]
fn if_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var block = ctx.blocks.take_back();
  var predicate = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut predicate); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut predicate.value))
    return bad_value;

  is = std::span(is.data, block.1.end);

  if (predicate.value.integer == 0)
  {
    is = block.1;

    switch (peek_op(is))
    {
      case else_op:
        is.drop_front!(1);

        var len = 0;
        if (!scan_pkg_length(&mut is, &mut len))
          return unexpected_end_of_stream;
    }
  }

  return ok;
}

#[noinline]
fn while_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var predicate = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut predicate); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut predicate.value))
    return bad_value;

  if (predicate.value.integer != 0)
  {
    ctx.push_state(state::while_op);
    ctx.push_state(state::term_arg);
    ctx.push_state(state::loop);
    ctx.push_state(state::term_list);
  }

  return ok;
}

#[noinline]
fn break_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  ctx.pop_state();
  ctx.pop_state();
  ctx.pop_state();
  ctx.pop_state();

  return ok;
}

#[noinline]
fn continue_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  ctx.pop_state();

  return ok;
}

#[noinline]
fn notify_op(context mut &ctx, std::span<u8> mut &is) -> result
{
  var value = ctx.stack.take_back();
  var name = ctx.stack.take_back();

  if (var rc = load(&mut ctx, &mut value); !rc)
    return rc;

  if (!ctx.namespace.to_integer(&mut value.value))
    return bad_value;

  switch (resolve(ctx, &mut name))
  {
    case Some[node]:

      for (; node; node = node.parent)
      {
        if (var obj = node.find(name.span))
          break;
      }

      if (var obj = node.find(name.span))
        ctx.namespace.notify(obj?!, value.value);

    else:
      return invalid_path;
  }

  ctx.pop_state();

  return ok;
}

#[noinline]
fn store(context mut &ctx, std::span<u8> mut &is) -> result
{
  var src = ctx.stack.back();

  if (var rc = load(&mut ctx, &mut src); !rc)
    return rc;

  switch (ctx.targets.take_back())
  {
    case nul:
      ;

    case debug:

      std::print("acpi debug: ", src.value);

    case arg[idx]:

      switch (ctx.arg(idx).value)
      {
        case reference[reference]:

          switch (reference)
          {
            case local[idx]:
              ctx.stack[idx] = &move src;

            case value[dst]:
              if (var rc = ctx.namespace.store(dst, &mut src.value); !rc)
                return rc;

            case index[index]:
              if (var rc = ctx.namespace.store(index.0, index.1, &mut src.value); !rc)
                return rc;
          }

        else:
          ctx.arg(idx) = &move src;
      }

    case local[idx]:

      ctx.local(idx) = &move src;

    case name[name]:

      var dst = lookup(ctx, name);

      if (!dst)
        return name_not_found;

      if (var rc = ctx.namespace.store(dst?!, &mut src.value); !rc)
        return rc;

    case reference[reference]:

      switch (reference)
      {
        case local[idx]:
          ctx.stack[idx] = &move src;

        case value[dst]:
          if (var rc = ctx.namespace.store(dst, &mut src.value); !rc)
            return rc;

        case index[index]:
          if (var rc = ctx.namespace.store(index.0, index.1, &mut src.value); !rc)
            return rc;
      }

    else:
      return invalid_target;
  }

  return ok;
}

#[noinline]
fn end(context mut &ctx, std::span<u8> &is) -> result
{
  for (var &value : ctx.values)
  {
    switch (value)
    {
      case opregion[opregion]:
        ctx.namespace.close(opregion);

      case mutex[mutex]:
        ctx.namespace.destroy_mutex(mutex);
    }
  }

  return ok;
}

fn evaluate(context mut &ctx, std::span<u8> is) -> result
{
  ctx.state = state::stream_start;

  while (ctx.state != state::end)
  {
    switch (ctx.state)
    {
      case stream_start:

        if (var rc = stream_start(&mut ctx, &mut is); !rc)
          return rc;

      case pkg_length:

        if (var rc = pkg_length(&mut ctx, &mut is); !rc)
          return rc;

      case byte_data:

        if (var rc = byte_data(&mut ctx, &mut is); !rc)
          return rc;

      case word_data:

        if (var rc = word_data(&mut ctx, &mut is); !rc)
          return rc;

      case dword_data:

        if (var rc = dword_data(&mut ctx, &mut is); !rc)
          return rc;

      case qword_data:

        if (var rc = qword_data(&mut ctx, &mut is); !rc)
          return rc;

      case name_string:

        if (var rc = name_string(&mut ctx, &mut is); !rc)
          return rc;

      case obj_string:

        if (var rc = obj_string(&mut ctx, &mut is); !rc)
          return rc;

      case num_elements:

        if (var rc = num_elements(&mut ctx, &mut is); !rc)
          return rc;

      case package_element_list:

        if (var rc = package_element_list(&mut ctx, &mut is); !rc)
          return rc;

      case package_element:

        if (var rc = package_element(&mut ctx, &mut is); !rc)
          return rc;

      case package:

        if (var rc = package(&mut ctx, &mut is); !rc)
          return rc;

      case buffer:

        if (var rc = buffer(&mut ctx, &mut is); !rc)
          return rc;

      case target:

        if (var rc = target(&mut ctx, &mut is); !rc)
          return rc;

      case target_refof:

        if (var rc = target_refof(&mut ctx, &mut is); !rc)
          return rc;

      case target_derefof:

        if (var rc = target_derefof(&mut ctx, &mut is); !rc)
          return rc;

      case term_arg:

        if (var rc = term_arg(&mut ctx, &mut is); !rc)
          return rc;

      case term_list:

        if (var rc = term_list(&mut ctx, &mut is); !rc)
          return rc;

      case define_name:

        if (var rc = define_name(&mut ctx, &mut is); !rc)
          return rc;

      case define_alias:

        if (var rc = define_alias(&mut ctx, &mut is); !rc)
          return rc;

      case define_scope:

        if (var rc = define_scope(&mut ctx, &mut is); !rc)
          return rc;

      case define_device:

        if (var rc = define_device(&mut ctx, &mut is); !rc)
          return rc;

      case define_processor:

        if (var rc = define_processor(&mut ctx, &mut is); !rc)
          return rc;

      case define_powerres:

        if (var rc = define_powerres(&mut ctx, &mut is); !rc)
          return rc;

      case define_thermalzone:

        if (var rc = define_thermalzone(&mut ctx, &mut is); !rc)
          return rc;

      case define_field:

        if (var rc = define_field(&mut ctx, &mut is); !rc)
          return rc;

      case define_indexfield:

        if (var rc = define_indexfield(&mut ctx, &mut is); !rc)
          return rc;

      case define_bankfield:

        if (var rc = define_bankfield(&mut ctx, &mut is); !rc)
          return rc;

      case define_opregion:

        if (var rc = define_opregion(&mut ctx, &mut is); !rc)
          return rc;

      case define_method:

        if (var rc = define_method(&mut ctx, &mut is); !rc)
          return rc;

      case define_mutex:

        if (var rc = define_mutex(&mut ctx, &mut is); !rc)
          return rc;

      case define_event:

        if (var rc = define_event(&mut ctx, &mut is); !rc)
          return rc;

      case create_field:
      case create_bit_field:
      case create_byte_field:
      case create_word_field:
      case create_dword_field:
      case create_qword_field:

        if (var rc = create_field(&mut ctx, &mut is); !rc)
          return rc;

      case not_op:
      case l_not_op:

        if (var rc = unary_op(&mut ctx, &mut is); !rc)
          return rc;

      case l_equal_op:
      case l_greater_op:
      case l_less_op:

        if (var rc = compare_op(&mut ctx, &mut is); !rc)
          return rc;

      case and_op:
      case nand_op:
      case or_op:
      case nor_op:
      case xor_op:
      case l_and_op:
      case l_or_op:
      case add_op:
      case subtract_op:
      case multiply_op:
      case divide_op:
      case mod_op:
      case shiftleft_op:
      case shiftright_op:

        if (var rc = binary_op(&mut ctx, &mut is); !rc)
          return rc;

      case increment_op:

        if (var rc = increment_op(&mut ctx, &mut is); !rc)
          return rc;

      case decrement_op:

        if (var rc = decrement_op(&mut ctx, &mut is); !rc)
          return rc;

      case refof_op:

        if (var rc = refof_op(&mut ctx, &mut is); !rc)
          return rc;

      case condrefof_op:

        if (var rc = condrefof_op(&mut ctx, &mut is); !rc)
          return rc;

      case index_op:

        if (var rc = index_op(&mut ctx, &mut is); !rc)
          return rc;

      case derefof_op:

        if (var rc = derefof_op(&mut ctx, &mut is); !rc)
          return rc;

      case match_op:

        if (var rc = match_op(&mut ctx, &mut is); !rc)
          return rc;

      case mid_op:

        if (var rc = mid_op(&mut ctx, &mut is); !rc)
          return rc;

      case concat_op:

        if (var rc = concat_op(&mut ctx, &mut is); !rc)
          return rc;

      case to_buffer:

        if (var rc = to_buffer(&mut ctx, &mut is); !rc)
          return rc;

      case to_decimalstring:

        if (var rc = to_decimalstring(&mut ctx, &mut is); !rc)
          return rc;

      case to_hexstring:

        if (var rc = to_hexstring(&mut ctx, &mut is); !rc)
          return rc;

      case to_integer:

        if (var rc = to_integer(&mut ctx, &mut is); !rc)
          return rc;

      case sizeof_op:

        if (var rc = sizeof_op(&mut ctx, &mut is); !rc)
          return rc;

      case acquire_op:

        if (var rc = acquire_op(&mut ctx, &mut is); !rc)
          return rc;

      case release_op:

        if (var rc = release_op(&mut ctx, &mut is); !rc)
          return rc;

      case stall_op:

        if (var rc = stall_op(&mut ctx, &mut is); !rc)
          return rc;

      case sleep_op:

        if (var rc = sleep_op(&mut ctx, &mut is); !rc)
          return rc;

      case timer_op:

        if (var rc = timer_op(&mut ctx, &mut is); !rc)
          return rc;

      case fatal_op:

        if (var rc = fatal_op(&mut ctx, &mut is); !rc)
          return rc;

      case load_op:

        if (var rc = load_op(&mut ctx, &mut is); !rc)
          return rc;

      case loaded:

        if (var rc = loaded(&mut ctx, &mut is); !rc)
          return rc;

      case return_op:

        if (var rc = return_op(&mut ctx, &mut is); !rc)
          return rc;

      case method_invocation:

        if (var rc = method_invocation(&mut ctx, &mut is); !rc)
          return rc;

      case method_call:

        if (var rc = method_call(&mut ctx, &mut is); !rc)
          return rc;

      case if_op:

        if (var rc = if_op(&mut ctx, &mut is); !rc)
          return rc;

      case while_op:

        if (var rc = while_op(&mut ctx, &mut is); !rc)
          return rc;

      case break_op:

        if (var rc = break_op(&mut ctx, &mut is); !rc)
          return rc;

      case continue_op:

        if (var rc = continue_op(&mut ctx, &mut is); !rc)
          return rc;

      case notify_op:

        if (var rc = notify_op(&mut ctx, &mut is); !rc)
          return rc;

      case store:

        if (var rc = store(&mut ctx, &mut is); !rc)
          return rc;

      case pkg:

        is = ctx.blocks.take_back().1;

      case loop:

        is = ctx.blocks.back.0;

      case end_scope:

        ctx.scopes.pop_back();

      case pop_frame:

        is = ctx.pop_frame();

      case pop:

        ctx.stack.pop_back();

      else:
        std::panic("invalid state");
    }

    ctx.state = ctx.pop_state();
  }

  end(&mut ctx, is);

  return ok;
}

pub fn parse(namespace mut &ns, std::span<u8> is) -> result
{
  var ctx = context(&mut ns);

  ctx.push_scope(ns.root);

  if (var rc = evaluate(&mut ctx, is); !rc)
    return rc;

  return ok;
}

pub fn execute(namespace mut &ns, acpi::method &method, value mut &dst, std::span<value> args) -> result
{
  var ctx = context(&mut ns);

  for (var &arg : args)
    ctx.push_value(arg);

  if (cast<usize>(method.flags & 0x7) != args.len)
    return bad_arg_count;

  ctx.push_frame(args.len, method.scope, std::span<u8>());

  if (var rc = evaluate(&mut ctx, method.code); !rc)
    return rc;

  if (ctx.stack.len > NARGS + NLOCALS)
    dst = ctx.stack.take_back().value;

  return ok;
}

pub fn execute<Args>(namespace mut &ns, acpi::method &method, value mut &dst, Args && ...args) -> result
{
  var ctx = context(&mut ns);

  #for (var &&arg : &&args)
    ctx.push_value(&&arg);

  if (cast<usize>(method.flags & 0x7) != args.len)
    return bad_arg_count;

  ctx.push_frame(args.len, method.scope, std::span<u8>());

  if (var rc = evaluate(&mut ctx, method.code); !rc)
    return rc;

  if (ctx.stack.len > NARGS + NLOCALS)
    dst = ctx.stack.take_back().value;

  return ok;
}
