//
// gallery
//

import std.stdio;
import gui.application;
import gui.window;
import gui.painter;
import gfx;
import app.loop;
import os.zaos.time;
import zuic.gallery;

pub struct window : pub gui::window
{
  zuic::Gallery view;

  app::loop::timeout_t animation_timer;

  pub fn create(i32 width, i32 height) throws(std::error) -> window
  {
    var window = window();

    window.animation_timer.callback = &cast<fn (app::loop mut &, app::loop::timeout_t mut *) -> void>(animation_timer);

    window.create(width, height);

    return window;
  }

  pub fn motion_event(this mut &, gui::pointer_event &evt) override -> void
  {
    {
      var evt = evt;
      evt.position.0 -= this.interior.left;
      evt.position.1 -= this.interior.top;

      gui::scene_event(&mut this.view.scene, evt);

      this.schedule_redraw(this.interior);
    }

    gui::window::motion_event(&mut this, evt);
  }

  pub fn button_event(this mut &, gui::pointer_event &evt) override -> void
  {
    {
      var evt = evt;
      evt.position.0 -= this.interior.left;
      evt.position.1 -= this.interior.top;

      gui::scene_event(&mut this.view.scene, evt);

      this.schedule_redraw(this.interior);
    }

    gui::window::button_event(&mut this, evt);
  }

  pub fn key_event(this mut &, gui::key_event &evt) override -> void
  {
    gui::window::key_event(&mut this, evt);
  }

  pub fn paint_event(this mut &, gui::buffer mut &buffer, gui::rectset &region) override -> void
  {
    var painter = gui::painter(&mut buffer, this.interior);
    var extents = gui::clamp(region.extents, this.interior).offset(-this.interior.top_left);

    painter.fill_rect(extents, gfx::color(0.94, 0.94, 0.94));
    painter.clip_rect = gfx::rect(cast(extents.left), cast(extents.top), cast(extents.width), cast(extents.height));

    var deadline = ~0;
    this.view.update(&mut deadline);

    if (deadline < ~0)
    {
      var now = os::timespec(void);
      os::clock_gettime(os::clock::monotonic, &now);

      this.animation_timer.deadline = now + deadline;

      app::loop::current.reset_timeout(&this.animation_timer);
    }

    gui::scene_render(&mut painter, this.view.scene);
  }

  pub fn animation_timer(app::loop mut &loop, app::loop::timeout_t mut *timeout) -> void
  {
    var this = cast<window mut *>(cast<uintptr>(timeout) - offsetof(window::animation_timer));

    this.schedule_redraw(this.interior);
  }

  pub fn resize_event(this mut &, gui::resize_event &evt) override -> void
  {
    this.view.resize(cast(this.interior.width), cast(this.interior.height));
  }

  pub fn close_event(this mut &) override -> void
  {
    app::loop::current.quit();
  }

  pub window()
    : super(&impl this)
  {
  }

  pub ~window() = default;
}

fn main() -> int
{
  try
  {
    var app = gui::application::create();

    var window = window::create(480, 240);

    app.run();
  }
  catch (std::error e)
  {
    std::panic(e);
  }

  return 0;
}
