//
// winton
//

import std.stdio;
import std.box;
import app.loop;
import os.zaos.mman;
import os.zaos.fcntl;
import zidl.zaos_sys;
import zidl.zaos_winton;
import frame;

using winton = zidl::zaos_winton;

extern fn thread_ring() -> os::ioring mut &;

pub struct rect
{
  pub i32 x;
  pub i32 y;
  pub i32 width;
  pub i32 height;

  pub rect(i32 x, i32 y, i32 width, i32 height)
    : x(x), y(y), width(width), height(height)
  {
  }

  pub fn ==(rect &lhs, rect &rhs) -> bool = default;

  pub rect() = default;
  pub rect(rect&) = default;
  pub fn =(rect mut &, rect &) -> rect mut & = default;
  pub ~rect() = default;
}

pub fn expand(rect &lhs, rect &rhs) -> rect
{
  var x1 = std::min(lhs.x, rhs.x);
  var y1 = std::min(lhs.y, rhs.y);
  var x2 = std::max(lhs.x + lhs.width, rhs.x + rhs.width);
  var y2 = std::max(lhs.y + lhs.height, rhs.y + rhs.height);

  return rect(x1, y1, x2 - x1, y2 - y1);
}

struct connection
{
  u32 next_id = 1;

  zidl::channel endpoint;
  app::loop::wait_t handler;

  u32 pointer;

  std::flat_hash_map<u32, surface mut *> surfaces;

  fn initialise(connection mut &this) throws -> void
  {
    this.endpoint = app::connect_to_service("zaos.winton/compositor");
    this.handler.callback = &cast<fn(app::loop mut &, app::loop::wait_t mut *)>(message_handler);

    app::loop::current.begin_wait(this.endpoint, &this.handler);

    this.pointer = this.create_surface();
  }

  pub fn create_surface(this mut &) throws -> u32
  {
    var id = this.next_id = std::add_with_carry(this.next_id, 1).0;

    zidl::send<winton::compositor::create_surface_request>(this.endpoint, id);

    return id;
  }

  pub fn create_buffer(this mut &, zidl::buffer fd, u32 offset, i32 width, i32 height, i32 stride, winton::format format) throws -> u32
  {
    var id = this.next_id = std::add_with_carry(this.next_id, 1).0;

    zidl::send<winton::compositor::create_buffer_request>(this.endpoint, id, &move fd, offset, width, height, stride, format);

    return id;
  }

  pub fn surface_attach(this mut &, u32 surface_id, u32 buffer_id) -> void
  {
    zidl::send<winton::compositor::surface_attach_request>(this.endpoint, surface_id, buffer_id);
  }

  pub fn surface_damage(this mut &, u32 surface_id, i32 x, i32 y, i32 width, i32 height) -> void
  {
    zidl::send<winton::compositor::surface_damage_request>(this.endpoint, surface_id, x, y, width, height);
  }

  pub fn surface_commit(this mut &, u32 surface_id, bool callback = false) -> void
  {
    zidl::send<winton::compositor::surface_commit_request>(this.endpoint, surface_id, callback);
  }

  pub fn surface_destroy(this mut &, u32 surface_id) -> void
  {
    zidl::send<winton::compositor::surface_destroy_request>(this.endpoint, surface_id);
  }

  pub fn buffer_resize(this mut &, u32 id, u32 offset, i32 width, i32 height, i32 stride, winton::format format) throws -> void
  {
    zidl::send<winton::compositor::buffer_resize_request>(this.endpoint, id, offset, width, height, stride, format);
  }

  pub fn buffer_destroy(this mut &, u32 buffer_id) -> void
  {
    zidl::send<winton::compositor::buffer_destroy_request>(this.endpoint, buffer_id);
  }

  pub fn create_window(this mut &, u32 surface_id) -> void
  {
    zidl::send<winton::compositor::create_window_request>(this.endpoint, surface_id);
  }

  pub fn acknowledge(this mut &, u32 serial) -> void
  {
    zidl::send<winton::compositor::acknowledge_request>(this.endpoint, serial);
  }

  pub fn set_cursor(this mut &, u32 serial, u32 surface_id, i32 hotspot_x, i32 hotspot_y) -> void
  {
    zidl::send<winton::compositor::set_cursor_request>(this.endpoint, serial, surface_id, hotspot_x, hotspot_y);
  }

  pub fn set_standard_cursor(this mut &, u32 serial, u32 surface_id, winton::cursor cursor) -> void
  {
    zidl::send<winton::compositor::set_standard_cursor_request>(this.endpoint, serial, surface_id, cursor);
  }

  pub fn set_minimised(this mut &, u32 surface_id) -> void
  {
    zidl::send<winton::compositor::set_minimised_request>(this.endpoint, surface_id);
  }

  pub fn set_maximised(this mut &, u32 surface_id) -> void
  {
    zidl::send<winton::compositor::set_maximised_request>(this.endpoint, surface_id);
  }

  pub fn set_fullscreen(this mut &, u32 surface_id) -> void
  {
    zidl::send<winton::compositor::set_fullscreen_request>(this.endpoint, surface_id);
  }

  pub fn unset_maximised(this mut &, u32 surface_id) -> void
  {
    zidl::send<winton::compositor::unset_maximised_request>(this.endpoint, surface_id);
  }

  pub fn unset_fullscreen(this mut &, u32 surface_id) -> void
  {
    zidl::send<winton::compositor::unset_fullscreen_request>(this.endpoint, surface_id);
  }

  pub fn move(this mut &, u32 serial, u32 surface_id) -> void
  {
    zidl::send<winton::compositor::move_request>(this.endpoint, serial, surface_id);
  }

  pub fn resize(this mut &, u32 serial, u32 surface_id, winton::tether tether) -> void
  {
    zidl::send<winton::compositor::resize_request>(this.endpoint, serial, surface_id, tether);
  }

  fn message_handler(app::loop mut &loop, app::loop::wait_t mut *wait) -> void
  {
    var connection = cast<connection mut *>(cast<uintptr>(wait) - offsetof(connection::handler));

    var result = zidl::recv<winton::compositor>(connection.endpoint, |msg, completer| {

      switch (msg)
      {
        case surface[msg]:
          ;

        case configure_window[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.configure_window(*surface.user, msg.width, msg.height, msg.state);
          }

        case configure_popup[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.configure_popup(*surface.user, msg.x, msg.y, msg.width, msg.height);
          }

        case configure[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.configure(*surface.user, msg.serial);
          }

        case surface_callback[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.callback(msg.time);
          }

        case buffer_release[msg]:
          for (var mut &(id, surface) : connection.surfaces)
            surface.release(msg.buffer_id);

        case pointer_enter[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.pointer_enter(*surface.user, msg.serial, msg.x, msg.y);
          }

        case pointer_leave[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.pointer_leave(*surface.user, msg.serial);
          }

        case pointer_motion[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.pointer_motion(*surface.user, msg.time, msg.x, msg.y);
          }

        case pointer_button[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.pointer_button(*surface.user, msg.time, msg.button, msg.state);
          }

        case pointer_wheel[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.pointer_wheel(*surface.user, msg.time, msg.dx, msg.dy);
          }

        case keyboard_enter[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.keyboard_enter(*surface.user, msg.serial);
          }

        case keyboard_leave[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.keyboard_leave(*surface.user, msg.serial);
          }

        case keyboard_key[msg]:
          switch (connection.surfaces.get(msg.surface_id))
          {
            case Some[surface]:
              surface.keyboard_key(*surface.user, msg.time, msg.key, msg.state, msg.sym);
          }

        case error[msg]:
          std::print("winton: error response - ", msg.code);

        else:
          std::print(msg);
          //completer.raise(zidl::errc::bad_dispatch);
      }
    });

    if (!result)
    {
      std::print("baz: client error - ", cast<zidl::errc>(-cast<i32>(result)));

      loop.cancel_wait(wait);
      connection.endpoint.close();
    }
  }

  connection() = default;
  ~connection() = default;
}

pub struct display : std::box<connection>
{
  pub fn create() throws -> display
  {
    var connection = std::box<connection>();

    connection::initialise(&mut *connection);

    return display(&move connection);
  }

  fn connection(this mut &) -> connection mut *
  {
    return &*this.super;
  }

  display(std::box<connection> &&connection)
    : super(&move connection)
  {
  }

  pub ~display() = default;
}

pub struct buffer
{
  u32 id;
  bool busy;

  pub i32 width;
  pub i32 height;
  pub i32 stride;
  pub u32 offset;
  pub usize size;
  pub u8 mut *data;

  pub buffer() = default;
  pub buffer(buffer&) = default;
  pub fn =(buffer mut &, buffer &) -> buffer mut & = default;
  pub ~buffer() = default;
}

pub vtable isurface
{
  fn configure_window(this mut &, i32 width, i32 height, winton::state state) -> void;
  fn configure_popup(this mut &, i32 x, i32 y, i32 width, i32 height) -> void;
  fn configure(this mut &, u32 serial) -> void;
  fn pointer_enter(this mut &, u32 serial, i32 x, i32 y) -> void;
  fn pointer_leave(this mut &, u32 serial) -> void;
  fn pointer_motion(this mut &, u64 time, i32 x, i32 y) -> void;
  fn pointer_button(this mut &, u64 time, u32 button, u32 state) -> void;
  fn pointer_wheel(this mut &, u64 time, i32 dx, i32 dy) -> void;
  fn keyboard_enter(this mut &, u32 serial) -> void;
  fn keyboard_leave(this mut &, u32 serial) -> void;
  fn keyboard_key(this mut &, u64 time, u32 key, u32 state, char sym) -> void;
  fn recursor(this mut &) -> void;
  fn resize(this mut &) -> void;
  fn redraw(this mut &) -> void;
}

struct surface : pub isurface &
{
  u32 id;
  void mut *user;
  connection mut *connection;

  enum status
  {
    init = 0x1,
    resize = 0x2,
    redraw = 0x4,
    cursor = 0x8,
    update = 0x10,

    pub const fn ~(status lhs) -> status { return cast<status>(~cast<isize>(lhs)); }
    pub const fn &(status lhs, status rhs) -> status { return cast<status>(cast<isize>(lhs) & cast<isize>(rhs)); }
    pub const fn |(status lhs, status rhs) -> status { return cast<status>(cast<isize>(lhs) | cast<isize>(rhs)); }
  }

  status status;
  app::loop::timeout_t update;

  rect size;
  rect pending_size;
  rect damage;

  buffer[2] buffers;

  fn initialise(surface mut &this) throws -> void
  {
    var id = this.connection.create_surface();

    this.id = id;
    this.connection.surfaces.insert(id, &this);
  }

  fn acknowledge(surface mut &this, u32 serial) -> void
  {
    this.connection.acknowledge(serial);

    if (this.status & status::init != status::init)
      this.status |= status::init;

    if (this.status & status::update != status::update)
      update_handler(&mut *app::loop::current, &this.update);
  }

  fn callback(surface mut &this, u64 time) -> void
  {
    update_handler(&mut *app::loop::current, &this.update);
  }

  fn release(surface mut &this, u32 buffer_id) -> void
  {
    for (var mut &buffer : this.buffers)
      if (buffer.id == buffer_id)
        buffer.busy = false;
  }

  fn schedule_update(this mut &) -> void
  {
    if (this.status & status::update != status::update)
    {
      var now = os::timespec(void);
      os::clock_time(os::clock::monotonic, &now);

      this.update.deadline = now;
      this.update.callback = &cast<fn(app::loop mut &, app::loop::timeout_t mut *)>(update_handler);

      app::loop::current.begin_timeout(&this.update);

      this.status |= status::update;
    }
  }

  fn update_handler(app::loop mut &loop, app::loop::timeout_t mut *timeout) -> void
  {
    var surface = cast<surface mut *>(cast<uintptr>(timeout) - offsetof(surface::update));

    surface.status &= ~status::update;

    if (surface.status & status::resize == status::resize)
      surface.resize(*surface.user);

    if (surface.status & status::redraw == status::redraw)
      surface.redraw(*surface.user);

    if (surface.status & status::cursor == status::cursor)
      surface.recursor(*surface.user);
  }

  fn get(this mut &) throws -> buffer mut &
  {
    for (var mut &buffer : this.buffers)
    {
      if (!buffer.busy)
        return &buffer;
    }

    throw std::system_error(std::errc::device_busy);
  }

  fn prepare(this mut &, buffer mut &buffer, rect allocation) throws -> void
  {
    var width = allocation.width;
    var height = allocation.height;

    if (buffer.width == width && buffer.height == height)
      return;

    var size = cast<usize>(std::align_up(width, 64)) * cast<usize>(std::align_up(height, 64)) * sizeof<u32>;

    if (buffer.size == size)
    {
      buffer.width = width;
      buffer.height = height;
      buffer.stride = width * sizeof<u32>;

      this.connection.buffer_resize(buffer.id, buffer.offset, buffer.width, buffer.height, buffer.stride, winton::format::B8G8R8A8);

      return;
    }

    if (buffer.data)
    {
      this.connection.buffer_destroy(buffer.id);

      os::munmap(buffer.data, buffer.size);
    }

    var (client_end, server_end) = zidl::buffer::create(size);

    var mmvec = os::mmvec();
    mmvec.offset = 0;
    mmvec.length = size;
    mmvec.flags = 0;
    mmvec.prot = os::prot::readwrite;

    var addr = null<u8 mut *>();
    if (var rc = os::mmap(client_end.fd, &mmvec, 1, &addr, 0); rc < 0)
      throw std::system_error(cast<std::errc>(-rc));

    buffer.width = width;
    buffer.height = height;
    buffer.stride = width * sizeof<u32>;
    buffer.offset = 0;
    buffer.size = mmvec.length;
    buffer.data = addr;
    buffer.id = this.connection.create_buffer(&move server_end, buffer.offset, buffer.width, buffer.height, buffer.stride, winton::format::B8G8R8A8);
  }

  fn swap(this mut &, buffer mut &buffer) throws -> void
  {
    this.connection.surface_attach(this.id, buffer.id);
    this.connection.surface_damage(this.id, this.damage.x, this.damage.y, this.damage.width, this.damage.height);
    this.connection.surface_commit(this.id, callback: true);

    buffer.busy = true;
    this.damage = rect(this.size.width, this.size.height, -this.size.width, -this.size.height);
    this.status |= status::update;
  }

  fn destroy(this mut &) -> void
  {
    for (var mut &buffer : this.buffers)
    {
      this.connection.buffer_destroy(buffer.id);

      os::munmap(buffer.data, buffer.size);

      buffer.data = null;
      buffer.size = 0;
    }

    this.connection.surface_destroy(this.id);
    this.connection.surfaces.erase(this.id);

    app::loop::current.cancel_timeout(&this.update);
    this.status = cast(0);
  }

  fn vtable(this&) -> isurface &
  {
    return &this.super;
  }

  surface(isurface &isurface, connection mut *connection)
    : super(&isurface), connection(connection)
  {
  }

  ~surface() = default;
}

pub struct input
{
  pub u64 time;
  pub u32 focus_serial;
  pub (i32,i32) position;
  pub (i32,i32) angle;

  pub u8[256] key_state;
  pub u8[32] button_state;

  pub u32 last_key;
  pub char last_sym;
  pub u32 last_button;

  u32 pressed_count;

  input() = default;
  input(input&&) = default;
  ~input() = default;
}

pub vtable iwindow : pub isurface
{
  fn configure_event(this mut &, u32 serial) -> void;
  fn motion_event(this mut &, input &) -> void;
  fn button_event(this mut &, input &) -> void;
  fn wheel_event(this mut &, input &) -> void;
  fn focus_event(this mut &) -> void;
  fn key_event(this mut &, input &) -> void;
  fn resize_event(this mut &) -> void;
  fn paint_event(this mut &, buffer mut &) -> void;
  fn close_event(this mut &) -> void;
}

pub struct window : pub std::box<surface>
{
  pub enum flags
  {
    close_button = 0x1000,
    minimise_button = 0x02000,
    maximise_button = 0x04000,

    resizeable = 0x10000,

    pub const fn bool(flags lhs) -> bool { return cast<isize>(lhs) != 0; }

    pub const fn ~(flags lhs) -> flags { return cast<flags>(~cast<isize>(lhs)); }
    pub const fn &(flags lhs, flags rhs) -> flags { return cast<flags>(cast<isize>(lhs) & cast<isize>(rhs)); }
    pub const fn |(flags lhs, flags rhs) -> flags { return cast<flags>(cast<isize>(lhs) | cast<isize>(rhs)); }
  }

  struct state
  {
    u32 title_color;
    u32 text_color;
    u32 hit_color;
    u32 close_color;
    frame::options options;
    frame::location location;

    winton::state state;
    winton::state pending_state;

    state() = default;
    state(state&&) = default;
    ~state() = default;
  }

  flags flags;
  input input;
  state state;
  winton::cursor cursor;

  pub fn create(display &&display, flags flags, iwindow &interface) throws -> window
  {
    var surface = std::box<surface>(interface, display.connection);

    surface::initialise(&mut *surface);

    display.connection.create_window(surface.id);
    display.connection.surface_commit(surface.id);

    return window(&move surface, flags);
  }

  pub fn create(display &&display, flags flags) throws -> window
  {
    return create(display, iwindow());
  }

  pub fn geometry(this&) -> rect
  {
    return this.size;
  }

  pub fn interior(this&) -> rect
  {
    if (this.is_fullscreen)
      return rect(0, 0, this.size.width, this.size.height);

    if (this.is_maximised)
      return rect(0, frame::maximised_interior_top, this.size.width, this.size.height - frame::maximised_interior_top);

    return rect(frame::interior_left, frame::interior_top, this.size.width - frame::interior_left - frame::interior_right, this.size.height - frame::interior_top - frame::interior_bottom);
  }

  pub fn is_active(this&) -> bool
  {
    return this.state.state & winton::state::activated == winton::state::activated;
  }

  pub fn is_minimised(this&) -> bool
  {
    return this.state.state & winton::state::minimised == winton::state::minimised;
  }

  pub fn is_maximised(this&) -> bool
  {
    return this.state.state & winton::state::maximised == winton::state::maximised;
  }

  pub fn is_fullscreen(this&) -> bool
  {
    return this.state.state & winton::state::fullscreen == winton::state::fullscreen;
  }

  pub fn set_cursor(this mut &, winton::cursor cursor) -> void
  {
    if (this.cursor == cursor)
      return;

    this.cursor = cursor;

    this.status |= surface::status::cursor;

    this.schedule_update();
  }

  pub fn schedule_resize(this mut &, i32 width, i32 height) -> void
  {
    this.pending_size.width = width;
    this.pending_size.height = height;

    this.status |= surface::status::resize;

    if (this.status & surface::status::init == surface::status::init)
      this.schedule_update();
  }

  pub fn schedule_redraw(this mut &, rect rect) -> void
  {
    this.damage = expand(this.damage, rect);

    this.status |= surface::status::redraw;

    this.schedule_update();
  }

  pub fn configure_window(this mut &, i32 width, i32 height, winton::state state) -> void
  {
    this.state.pending_state = state;

    if (width != 0 && height != 0)
    {
      this.pending_size.width = width;
      this.pending_size.height = height;
    }
  }

  pub fn configure_popup(this mut &, i32 x, i32 y, i32 width, i32 height) -> void
  {
  }

  pub fn configure(this mut &, u32 serial) -> void
  {
    if (this.size != this.pending_size)
    {
      this.status |= surface::status::resize;
    }

    if (this.state.state != this.state.pending_state)
    {
      this.state.state = this.state.pending_state;
      this.damage = expand(this.damage, rect(0, 0, this.size.width, this.interior.y));
      this.status |= surface::status::redraw;
    }

    this.vtable.configure_event(*this.user, serial);
  }

  pub fn set_minimised(this mut &) -> void
  {
    this.connection.set_minimised(this.id);
  }

  pub fn set_maximised(this mut &, bool maximised) -> void
  {
    switch (maximised)
    {
      case true:
        this.connection.set_maximised(this.id);

      else:
        this.connection.unset_maximised(this.id);
    }
  }

  pub fn set_fullscreen(this mut &, bool fullscreen) -> void
  {
    switch (fullscreen)
    {
      case true:
        this.connection.set_fullscreen(this.id);

      else:
        this.connection.unset_fullscreen(this.id);
    }
  }

  pub fn pointer_enter(this mut &, u32 serial, i32 x, i32 y) -> void
  {
    this.input.focus_serial = serial;
    this.status |= surface::status::cursor;
  }

  pub fn pointer_leave(this mut &, u32 serial) -> void
  {
    this.state.location = frame::location::exterior;

    this.schedule_redraw(this.size);
  }

  pub fn pointer_motion(this mut &, u64 time, i32 x, i32 y) -> void
  {
    this.input.time = time;
    this.input.position.0 = x;
    this.input.position.1 = y;

    var location = frame::location(this.input.position.0, this.input.position.1, this.size.width, this.size.height, this.state.options);

    if (this.input.pressed_count == 0)
    {
      switch (location)
      {
        case top_side:
          this.set_cursor(winton::cursor::resize_top);

        case left_side:
          this.set_cursor(winton::cursor::resize_left);

        case bottom_side:
          this.set_cursor(winton::cursor::resize_bottom);

        case right_side:
          this.set_cursor(winton::cursor::resize_right);

        case top_left_corner:
          this.set_cursor(winton::cursor::resize_top_left);

        case top_right_corner:
          this.set_cursor(winton::cursor::resize_top_right);

        case bottom_left_corner:
          this.set_cursor(winton::cursor::resize_bottom_left);

        case bottom_right_corner:
          this.set_cursor(winton::cursor::resize_bottom_right);

        case minimise:
        case maximise:
        case close:
        case title:
          this.set_cursor(winton::cursor::arrow);
      }

      if (location != this.state.location)
      {
        this.state.location = location;

        this.schedule_redraw(rect(0, 0, this.size.width, this.interior.y));
      }
    }

    switch (this.state.location)
    {
      case interior:
        this.vtable.motion_event(*this.user, this.input);
    }

    if (this.status & surface::status::cursor == surface::status::cursor)
      this.recursor();
  }

  pub fn pointer_button(this mut &, u64 time, u32 button, u32 state) -> void
  {
    this.input.time = time;
    this.input.last_button = button;

    if (button < 32)
      this.input.button_state[cast(button)] = cast(state);

    switch (state)
    {
      case 1:
        this.input.pressed_count += 1;

      case 0:
        this.input.pressed_count -= 1;
    }

    if (this.input.pressed_count == 1 && state == 1)
    {
      switch (this.state.location)
      {
        case top_side:
          this.connection.resize(this.input.focus_serial, this.id, winton::tether::top);

        case left_side:
          this.connection.resize(this.input.focus_serial, this.id, winton::tether::left);

        case bottom_side:
          this.connection.resize(this.input.focus_serial, this.id, winton::tether::bottom);

        case right_side:
          this.connection.resize(this.input.focus_serial, this.id, winton::tether::right);

        case top_left_corner:
          this.connection.resize(this.input.focus_serial, this.id, winton::tether::top_left);

        case top_right_corner:
          this.connection.resize(this.input.focus_serial, this.id, winton::tether::top_right);

        case bottom_left_corner:
          this.connection.resize(this.input.focus_serial, this.id, winton::tether::bottom_left);

        case bottom_right_corner:
          this.connection.resize(this.input.focus_serial, this.id, winton::tether::bottom_right);

        case title:
          this.connection.move(this.input.focus_serial, this.id);
      }
    }

    if (this.input.pressed_count == 0 && state == 0)
    {
      switch (this.state.location)
      {
        case close:
          if (frame::location(this.input.position.0, this.input.position.1, this.size.width, this.size.height, this.state.options) == this.state.location)
            this.vtable.close_event(*this.user);

        case maximise:
          if (frame::location(this.input.position.0, this.input.position.1, this.size.width, this.size.height, this.state.options) == this.state.location)
            this.set_maximised(!this.is_maximised);

        case minimise:
          if (frame::location(this.input.position.0, this.input.position.1, this.size.width, this.size.height, this.state.options) == this.state.location)
            this.set_minimised();
      }
    }

    switch (this.state.location)
    {
      case interior:
        this.vtable.button_event(*this.user, this.input);
    }
  }

  pub fn pointer_wheel(this mut &, u64 time, i32 dx, i32 dy) -> void
  {
    this.input.time = time;
    this.input.angle.0 = dx;
    this.input.angle.1 = dy;

    switch (this.state.location)
    {
      case interior:
        this.vtable.wheel_event(*this.user, this.input);
    }
  }

  pub fn keyboard_enter(this mut &, u32 serial) -> void
  {
    this.vtable.focus_event(*this.user);
  }

  pub fn keyboard_leave(this mut &, u32 serial) -> void
  {
    this.vtable.focus_event(*this.user);
  }

  pub fn keyboard_key(this mut &, u64 time, u32 key, u32 state, char sym) -> void
  {
    this.input.time = time;
    this.input.last_key = key;
    this.input.last_sym = sym;

    if (key < 256)
      this.input.key_state[cast(key)] = cast(state);

    this.vtable.key_event(*this.user, this.input);
  }

  pub fn resize(this mut &) -> void
  {
    if (this.size != this.pending_size)
    {
      this.size = this.pending_size;
      this.damage = this.size;
      this.status |= surface::status::redraw;

      this.vtable.resize_event(*this.user) -> void;
    }

    this.status &= ~surface::status::resize;
  }

  pub fn redraw(this mut &) -> void
  {
    try
    {
      var mut &buffer = this.get();

      this.prepare(&mut buffer, this.size);

      this.state.options = cast(0);

      if (this.flags & flags::close_button)
        this.state.options |= frame::options::close;

      if (this.flags & flags::minimise_button)
        this.state.options |= frame::options::minimise;

      if (this.flags & flags::maximise_button)
        this.state.options |= frame::options::maximise;

      if (this.is_maximised)
        this.state.options |= frame::options::maximised;

      if (this.is_fullscreen)
        this.state.options |= frame::options::fullscreen;

      var location = this.state.location;

      var title_color = this.state.title_color;
      if (!this.is_active)
        title_color = title_color - 0x00010101;

      var text_color = this.state.text_color;
      if (!this.is_active)
        text_color = text_color + 0x00555555;

      var hit_color = this.state.hit_color;
      if (location == frame::location::close)
        hit_color = this.state.close_color;

      frame::render(buffer.width, buffer.height, cast<usize>(buffer.stride), buffer.data + cast<usize>(buffer.offset), title_color, text_color, this.state.options, hit_color, location);

      this.vtable.paint_event(*this.user, &mut buffer);

      this.swap(&mut buffer);
    }
    catch(std::error e)
    {
      std::print("redraw - ", e);
    }

    this.status &= ~surface::status::redraw;
  }

  pub fn recursor(this mut &) -> void
  {
    this.connection.set_standard_cursor(this.input.focus_serial, this.connection.pointer, this.cursor);
    this.connection.surface_commit(this.connection.pointer);

    this.status &= ~surface::status::cursor;
  }

  pub fn configure_event(this mut &, u32 serial) -> void
  {
    this.acknowledge(serial);
  }

  pub fn motion_event(this mut &, input &) -> void
  {
    this.set_cursor(winton::cursor::arrow);
  }

  pub fn button_event(this mut &, input &) -> void
  {
  }

  pub fn wheel_event(this mut &, input &) -> void
  {
  }

  pub fn focus_event(this mut &) -> void
  {
  }

  pub fn key_event(this mut &, input &) -> void
  {
  }

  pub fn paint_event(this mut &, buffer mut &) -> void
  {
  }

  pub fn resize_event(this mut &) -> void
  {
  }

  pub fn close_event(this mut &) -> void
  {
  }

  pub fn destroy(this mut &) -> void
  {
    surface::destroy(&mut *this.super);
  }

  fn vtable(this&) -> iwindow &
  {
    return &cast<iwindow&>(this.super.vtable);
  }

  window(std::box<surface> &&surface, flags flags)
    : super(&move surface),
      flags(flags)
  {
    state.title_color = 0xffffffff;
    state.text_color = 0xff000000;
    state.hit_color = 0xffcccccc;
    state.close_color = 0xffcc4444;

    super.user = &this;
  }

  pub window(window &&other)
    where __is_rvalue<typeof(other)>
    : super(&move other.super),
      flags(&move other.flags),
      input(&move other.input),
      state(&move other.state),
  {
    super.user = &this;
  }

  pub ~window() = default;
}
