//
// coco
//

import std.stdio;
import display;
import terminal;
import basic.machine;
import basic.sys as sys;
import basic.gfx as gfx;
import seat;
import env;
import tab;

fn main()
{
  var seat = seat::create();
  if (var rc = seat::initialise(&mut seat); rc < 0)
    std::print("coco: failed to initialise input - ", cast<std::errc>(-rc));

  var display = display::create();
  if (var rc = display::initialise(&mut display); rc < 0)
    std::print("coco: failed to initialise display - ", cast<std::errc>(-rc));

  var terminal = terminal::create(&mut seat, &mut display);
  if (var rc = terminal::initialise(&mut terminal); rc < 0)
    std::print("coco: failed to initialise terminal - ", cast<std::errc>(-rc));

  if (var rc = terminal.set_font("/zaos/boot/unifont-14.0.03.hex"); rc < 0)
    std::print("coco: failed to set terminal font - ", cast<std::errc>(-rc));

  terminal.print(std::string_view("ZaOS Extended Colour Console\r\n\r\n"));
  terminal.render();

  var env = env::create();

  var vm = basic::machine();
  vm.stdin = std::input_stream(&mut terminal.termin);
  vm.stdout = std::output_stream(&mut terminal.termout);

  sys::initialise(&mut vm, &mut terminal);
  gfx::initialise(&mut vm, &mut terminal);

  while (true)
  {
    var username = [0; 128];

    terminal.write("login: ");

    if (terminal.read(&mut username) > 0)
    {
      var password = [0; 128];

      terminal.write("password: ");

      if (terminal.read_pass(&mut password) > 0)
      {
        if (env.login(username, password) == 0)
        {
          terminal.write("\nOK\n");

          break;
        }
      }
    }
  }

  while (true)
  {
    var completer = tab::completer();

    switch (terminal.read_line(&completer))
    {
      case enter[cmdline]:
        var args = cmdline.words;

        if (!args.empty)
        {
          var result = -2;

          switch (args.front)
          {
            case "ls":
              import cmds.ls : *;
              result = ls(&mut terminal, &mut env, cmdline);

            case "cd":
              import cmds.cd : *;
              result = cd(&mut terminal, &mut env, cmdline);

            case "cat":
              import cmds.cat : *;
              result = cat(&mut terminal, &mut env, cmdline);

            case "cp":
              import cmds.cp : *;
              result = cp(&mut terminal, &mut env, cmdline);

            case "pwd":
              import cmds.pwd : *;
              result = pwd(&mut terminal, &mut env, cmdline);

            case "stat":
              import cmds.stat : *;
              result = stat(&mut terminal, &mut env, cmdline);

            case "mkdir":
              import cmds.mkdir : *;
              result = mkdir(&mut terminal, &mut env, cmdline);

            case "rm":
              import cmds.rm : *;
              result = rm(&mut terminal, &mut env, cmdline);

            case "rename":
              import cmds.rename : *;
              result = rename(&mut terminal, &mut env, cmdline);

            case "symlink":
              import cmds.symlink : *;
              result = symlink(&mut terminal, &mut env, cmdline);

            case "ps":
              import cmds.ps : *;
              result = ps(&mut terminal, &mut env, cmdline);

            case "cls":
              import cmds.cls: *;
              result = cls(&mut terminal, &mut env, cmdline);

            case "reset":
              import cmds.reset : *;
              result = reset(&mut terminal, &mut vm, &mut env, cmdline);

            case "load":
              import cmds.load : *;
              result = load(&mut terminal, &mut vm, &mut env, cmdline);

            case "list":
              import cmds.list : *;
              result = list(&mut terminal, &mut vm, &mut env, cmdline);

            case "run":
            case "RUN":
            case "print":
            case "PRINT":
              import cmds.eval : *;
              result = eval(&mut terminal, &mut vm, &mut env, cmdline);

            else:
              import cmds.start : *;
              result = start(&mut terminal, &mut env, cmdline);
          }

          terminal.flush();

          if (terminal.x != 0)
            terminal.write("\x1b[36m%\x1b[0m\n");

          switch (result)
          {
            case 0:
              terminal.write("OK\n");

            case -2:
              terminal.write("?NOTFOUND\n");

            case -17:
              terminal.write("?EXISTS\n");

            else:
              terminal.write("?ERROR\n");
          }
        }

      else:
        terminal.write("?CANCELLED\n");
    }
  }
}
