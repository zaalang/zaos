//
// session
//

import std.stdio;
import std.string : String;
import std.flat_hash_map;
import std.box;
import os.zaos.fcntl : STDCWD_FILENO;
import os.zaos.sched;
import os.zaos.time;
import zidl.types;
import zidl.zaos.sys;
import app.loop : STDSYS_FILENO;

extern fn thread_ring() -> os::ioring mut &;

struct session
{
  std::vector<std::string> vars;

  fn vars()
  {
    return &instance.vars;
  }

  struct unit
  {
    std::vector<std::string> argv;

    i32 pid;
    zidl::channel channel;
    app::loop::wait_t status_handler;
    app::loop::wait_t channel_handler;

    unit() = default;
    ~unit() = default;
  }

  std::vector<std::box<unit>> units;
  std::flat_hash_map<std::string, unit mut *> services;

  fn units()
  {
    return &instance.units;
  }

  fn services()
  {
    return &instance.services;
  }

  struct client
  {
    zidl::channel channel;
    app::loop::wait_t handler;

    client() = default;
    ~client() = default;
  }

  std::vector<std::box<client>> clients;

  fn clients()
  {
    return &instance.clients;
  }

  fn instance() -> session mut &
  {
    static instance = #session();

    return &instance;
  }

  session() = default;
  session(#session&) = default;
  ~session() = default;
}

pub fn login() -> i32
{
  using os;

  var username = "root";
  var working_directory = "/zaos/root";

  session::vars.push_back(std::format("USER={}", username));
  session::vars.push_back(std::format("CWD={}", working_directory));

  var cwd = open(&mut thread_ring, os::string(working_directory), O_RDONLY, 0);

  if (cwd < 0)
    return cwd;

  if (var rc = dup2(&mut thread_ring, cwd, STDCWD_FILENO); rc < 0)
  {
    close(&mut thread_ring, cwd);

    return rc;
  }

  close(&mut thread_ring, cwd);

  return 0;
}

fn register(String &&uri, String &&path) -> session::unit mut *
{
  var mut &unit = session::units.push_back();

  unit.argv.push_back(&&path);

  session::services.insert(&&uri, &*unit);

  return &*unit;
}

fn spawn(session::unit mut &unit) -> i32
{
  using os;

  var argv = std::vector<os::arg>();
  var envp = std::vector<os::arg>();
  var attrs = std::vector<os::attr>();

  var server_end = zidl::channel();
  var client_end = zidl::channel();

  if (var rc = zidl::channel::create(&mut server_end, &mut client_end); rc < 0)
    return rc;

  for (var &arg : unit.argv)
    argv.push_back(os::arg(arg.data, arg.len));

  for (var &arg : session::vars)
    envp.push_back(os::arg(arg.data, arg.len));

  attrs.push_back(os::attr(attr::stdout, STDOUT_FILENO));
  attrs.push_back(os::attr(attr::stderr, STDOUT_FILENO));
  attrs.push_back(os::attr(attr::stdroot, STDROOT_FILENO));
  attrs.push_back(os::attr(attr::stdcwd, STDCWD_FILENO));
  attrs.push_back(os::attr(attr::dupfd(7), client_end.fd));

  var pid = process_create(argv.data, argv.len, envp.data, envp.len, attrs.data, attrs.len, 0);

  if (pid < 0)
    return pid;

  unit.pid = pid;
  unit.channel = &move server_end;
  unit.status_handler.callback = &cast<fn (app::loop mut &, app::loop::wait_t mut *) -> void>(status_handler);
  unit.channel_handler.callback = &cast<fn (app::loop mut &, app::loop::wait_t mut *) -> void>(channel_handler);

  if (var rc = app::loop::current.begin_wait_pid(unit.pid, &unit.status_handler); rc < 0)
    return rc;

  if (var rc = app::loop::current.begin_wait_fd(unit.channel.fd, &unit.channel_handler); rc < 0)
    return rc;

  std::print("session service launched (", unit.pid, ":", unit.argv[0], ")");

  return 0;
}

fn wait(session::unit mut &unit) -> i32
{
  using os;

  var rval = 0;
  if (var rc = wait(unit.pid, &rval, 0); rc < 0)
    return rc;

  std::print("session service exited (", unit.pid, ":", unit.argv[0], ") - ", rval);

  unit.channel.close();
  unit.pid = 0;

  return 0;
}

fn accept(zidl::string uri, zidl::channel channel) -> void
{
  var mut &client = session::clients.push_back();

  client.channel = &move channel;
  client.handler.callback = &cast<fn (app::loop mut &, app::loop::wait_t mut *) -> void>(launch_handler);

  app::loop::current.begin_wait_fd(client.channel.fd, &client.handler);
}

fn connect_to_service(zidl::string uri, zidl::channel endpoint) -> void
{
  var fd = STDSYS_FILENO;

  switch (session::services.get(uri.cut('/').0))
  {
    case Some[service]:
      fd = service.channel.fd;
  }

  zidl::send<zidl::zaos_sys::service::connect_to_service_request>(fd, uri, &move endpoint);
}

fn status_handler(app::loop mut &loop, app::loop::wait_t mut *wait) -> void
{
  var unit = cast<session::unit mut *>(cast<uintptr>(wait) - offsetof(session::unit::status_handler));

  if (var rc = unit.wait(); rc < 0)
    std::panic("session: service wait - ", cast<std::errc>(-rc));

  loop.cancel_wait(&unit.channel_handler);
  loop.cancel_wait(&unit.status_handler);
}

fn channel_handler(app::loop mut &loop, app::loop::wait_t mut *wait) -> void
{
  var unit = cast<session::unit mut *>(cast<uintptr>(wait) - offsetof(session::unit::channel_handler));

  var result = zidl::recv<zidl::zaos_sys::service>(unit.channel.fd, |msg, completer| {
    switch (msg)
    {
      case connect_to_service[msg]:
        switch (msg.uri)
        {
          case "zaos.sys/launcher":
            accept(msg.uri, &move msg.endpoint);

          else:
            connect_to_service(msg.uri, &move msg.endpoint);
        }

      else:
        completer.raise(zidl::errc::bad_dispatch);
    }
  });

  if (!result)
  {
    loop.cancel_wait(wait);
    unit.channel.close();
  }
}

fn launch(String &&path) -> i32
{
  var mut &unit = session::units.push_back();

  unit.argv.push_back(&&path);

  if (var rc = unit.spawn(); rc < 0)
    return rc;

  return 0;
}

fn launch(zidl::vector<zidl::string> &argv) -> i32
{
  var mut &unit = session::units.push_back();

  for (var &arg : argv)
    unit.argv.push_back(arg);

  if (var rc = unit.spawn(); rc < 0)
    return rc;

  return 0;
}

fn launch_handler(app::loop mut &loop, app::loop::wait_t mut *wait) -> void
{
  var client = cast<session::client mut *>(cast<uintptr>(wait) - offsetof(session::client::handler));

  var result = zidl::recv<zidl::zaos_sys::launcher>(client.channel, |msg, completer| {

    switch (msg)
    {
      case launch[msg]:
        launch(msg.argv);

      else:
        completer.raise(zidl::errc::bad_dispatch);
    }
  });

  if (!result)
  {
    loop.cancel_wait(wait);
    session::clients.erase_if(|k| &*k == client);
  }
}

fn main() -> int
{
  var loop = app::loop();

  if (var rc = app::initialise(&mut loop); rc < 0)
    std::panic("unable to init loop - ", cast<std::errc>(-rc));

  if (var rc = login(); rc < 0)
    std::panic("unable to init environment - ", cast<std::errc>(-rc));

  register("zaos.winton", "/zaos/srv/winton");
  register("zaos.lamina", "/zaos/srv/lamina");

  for (var mut &[uri, unit] : session::services)
  {
    if (var rc = unit.spawn(); rc < 0)
      std::panic("session: service spawn (", unit.argv[0], ") - ", cast<std::errc>(-rc));
  }

  //launch("/zaos/root/baz");
  //launch("/zaos/root/rings");
  launch("/zaos/root/triangle");
  launch("/zaos/bin/terminal");
  launch("/zaos/bin/terminal");

  loop.run();

  return 0;
}
