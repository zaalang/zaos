//
// compositor
//

import std.stdlib;
import std.flat_hash_map;
import std.box;
import std.arc;
import app.loop;
import seat;
import theme;
import scene;
import display;
import math : vec2, vec4, bound, transform;
import input.driver;
import os.zaos.mman;
import zidl.zaos_winton;

using winton = zidl::zaos_winton;

extern fn thread_ring() -> os::ioring mut &;

struct client
{
  compositor mut *compositor;

  zidl::channel channel;
  app::loop::wait_t handler;

  std::flat_hash_map<u32, std::box<surface>> surfaces;
  std::flat_hash_map<u32, std::arc<buffer>> buffers;

  u32 serial = 1;

  ~client()
  {
    destroy(&this);
  }

  client() = default;
}

struct surface
{
  u32 id;
  client mut *client;

  winton::uuid uuid;

  std::optional<std::arc<buffer>> active;
  std::optional<std::arc<buffer>> pending;

  bound damage;
  bound pending_damage;

  bool callback;

  scene::node *node;

  u32 configure_serial;

  i32 pending_width;
  i32 incoming_width;

  i32 pending_height;
  i32 incoming_height;

  zidl::zaos_winton::state pending_flags;
  zidl::zaos_winton::state incoming_flags;

  i32 pending_min_width;
  i32 pending_min_height;
  i32 pending_max_width;
  i32 pending_max_height;

  bound pending_visible_region;
  bound pending_opaque_region;
  bound pending_input_region;

  i32 restore_width;
  i32 restore_height;
  transform restore_local;

  winton::tether resize_tether;

  enum state
  {
    mapped = 0x1,

    pub const fn ~(state lhs) -> state { return cast<state>(~cast<isize>(lhs)); }
    pub const fn &(state lhs, state rhs) -> state { return cast<state>(cast<isize>(lhs) & cast<isize>(rhs)); }
    pub const fn |(state lhs, state rhs) -> state { return cast<state>(cast<isize>(lhs) | cast<isize>(rhs)); }
  }

  state state;

  ~surface()
  {
    destroy(&this);
  }

  surface() = default;
}

struct buffer
{
  u32 id;

  i32 width;
  i32 height;
  usize offset;
  usize stride;
  winton::format format;

  usize size;
  u8 mut *data;

  pub fn bound(this &) { return bound::from(vec2(0.0, 0.0), vec2(cast(this.width), cast(this.height))); }

  ~buffer()
  {
    destroy(&this);
  }

  buffer() = default;
}

enum grab
{
  none,
  move,
  resize,
}

struct pointer
{
  vec2 position;
  scene::node *focus;

  surface mut *surface;

  u32 focus_serial;
  u32 pressed_count;

  bool dirty_focus;

  grab grab_op;
  vec2 grab_pos;
  vec2 grab_offset;
  bound grab_bound;

  pointer() = default;
  ~pointer() = default;
}

struct keyboard
{
  scene::node *focus;

  surface mut *surface;

  u32 focus_serial;

  u8 shift_state;
  u8 control_state;
  u8 alt_state;
  u8 super_state;
  u8 hyper_state;
  u8 meta_state;

  winton::modifiers modifiers;

  keyboard() = default;
  ~keyboard() = default;
}

pub struct sprite
{
  std::arc<buffer> buffer;

  pub sprite() = default;
  pub sprite(sprite&&) = default;
  pub fn =(sprite mut &, sprite &&) -> sprite mut & = default;
  pub ~sprite() = default;
}

pub struct compositor
{
  seat::seat mut &seat;
  display::display mut &display;

  compositor(seat::seat mut &seat, display::display mut &display)
    : seat(&seat), display(&display)
  {
  }

  enum status
  {
    scheduled = 0x1,

    pub const fn ~(status lhs) -> status { return cast<status>(~cast<isize>(lhs)); }
    pub const fn &(status lhs, status rhs) -> status { return cast<status>(cast<isize>(lhs) & cast<isize>(rhs)); }
    pub const fn |(status lhs, status rhs) -> status { return cast<status>(cast<isize>(lhs) | cast<isize>(rhs)); }
  }

  status status;

  pointer pointer;
  keyboard keyboard;

  bound damage;
  scene::scene scene;
  theme::theme theme;

  std::vector<std::box<client>> clients;

  app::loop::timeout_t redraw_handler;

  vec2 placement = vec2(100.0, 100.0);

  pub ~compositor() = default;
}

pub fn create(seat::seat mut &seat, display::display mut &display) -> compositor
{
  return compositor(&mut seat, &mut display);
}

pub fn initialise(compositor mut &compositor) -> i32
{
  if (var rc = theme::initialise(&mut compositor.theme); rc < 0)
    return rc;

  if (var rc = scene::initialise(&mut compositor.scene); rc < 0)
    return rc;

  compositor.pointer.position.x = cast(compositor.display.width / 2);
  compositor.pointer.position.y = cast(compositor.display.height / 2);

  var now = os::timespec(void);
  os::clock_time(os::clock::monotonic, &now);

  compositor.redraw_handler.deadline = now;
  compositor.redraw_handler.callback = &cast<fn (app::loop mut &, app::loop::timeout_t mut *) -> void>(redraw_handler);

  compositor.seat.on_event = |event| input_handler(&compositor, event);

  return 0;
}

pub fn accept(compositor mut &compositor, zidl::string_view uri, zidl::channel channel) -> void
{
  std::print("winton compositor: accept connection");

  var mut &client = compositor.clients.push_back();

  client.compositor = &compositor;

  client.channel = &move channel;
  client.handler.callback = &cast<fn (app::loop mut &, app::loop::wait_t mut *) -> void>(client_handler);

  app::loop::current.begin_wait_fd(client.channel.fd, &client.handler);
}

pub fn create_sprite(i32 width, i32 height, i32 stride, u8 *data, winton::format format) -> sprite
{
  var sprite = sprite();

  sprite.buffer.width = width;
  sprite.buffer.height = height;
  sprite.buffer.stride = cast(stride);
  sprite.buffer.format = format;
  sprite.buffer.size = cast<usize>(height * stride);
  sprite.buffer.data = cast<u8 mut *>(std::allocator().allocate(sprite.buffer.size, 16));

  std::memcpy(sprite.buffer.data, data, sprite.buffer.size);

  return sprite;
}

pub fn sprite_destroy(sprite mut &sprite) -> void
{
  std::allocator().free(sprite.buffer.data, sprite.buffer.size);

  sprite.buffer.data = null;
  sprite.buffer.size = 0;
}

pub enum result : i32
{
  ok = 0,

  pub fn bool(result code) -> bool
  {
    return cast<i32>(code) >= 0;
  }

  pub fn ==(result code, winton::errc error) -> bool
  {
    return cast<i32>(code) == -cast<i32>(error);
  }

  pub fn result(winton::errc error) -> result
  {
    return cast(-cast<i32>(error));
  }

  pub fn result(i32 result) -> result
  {
    return cast(result);
  }
}

fn client_handler(app::loop mut &loop, app::loop::wait_t mut *wait) -> void
{
  var client = cast<client mut *>(cast<uintptr>(wait) - offsetof(client::handler));

  var result = zidl::recv<winton::compositor>(client.channel, |msg, completer| {

    var result = result::ok;

    switch (msg)
    {
      case create_surface[msg]:
        result = create_surface(client, msg.id);

      case create_buffer[msg]:
        result = create_buffer(client, msg.id, &move msg.handle, msg.offset, msg.width, msg.height, msg.stride, msg.format);

      case surface_attach[msg]:
        result = surface_attach(client, msg.surface_id, msg.buffer_id);

      case surface_damage[msg]:
        result = surface_damage(client, msg.surface_id, msg.x, msg.y, msg.width, msg.height);

      case surface_commit[msg]:
        result = surface_commit(client, msg.surface_id, msg.callback);

      case surface_destroy[msg]:
        result = surface_destroy(client, msg.surface_id);

      case buffer_resize[msg]:
        result = buffer_resize(client, msg.buffer_id, msg.offset, msg.width, msg.height, msg.stride, msg.format);

      case buffer_destroy[msg]:
        result = buffer_destroy(client, msg.buffer_id);

      case create_window[msg]:
        result = create_window(client, msg.surface_id);

      case create_popup[msg]:
        result = create_popup(client, msg.surface_id, msg.parent_id);

      case acknowledge[msg]:
        result = acknowledge(client, msg.serial);

      case set_cursor[msg]:
        result = set_cursor(client, msg.serial, msg.surface_id, msg.hotspot_x, msg.hotspot_y);

      case set_standard_cursor[msg]:
        result = set_standard_cursor(client, msg.serial, msg.surface_id, msg.cursor);

      case set_minimised[msg]:
        result = set_minimised(client, msg.surface_id);

      case set_maximised[msg]:
        result = set_maximised(client, msg.surface_id);

      case set_fullscreen[msg]:
        result = set_fullscreen(client, msg.surface_id);

      case unset_maximised[msg]:
        result = unset_maximised(client, msg.surface_id);

      case unset_fullscreen[msg]:
        result = unset_fullscreen(client, msg.surface_id);

      case set_visible_region[msg]:
        result = set_visible_region(client, msg.surface_id, msg.x, msg.y, msg.width, msg.height);

      case set_opaque_region[msg]:
        result = set_opaque_region(client, msg.surface_id, msg.x, msg.y, msg.width, msg.height);

      case set_input_region[msg]:
        result = set_input_region(client, msg.surface_id, msg.x, msg.y, msg.width, msg.height);

      case set_minimum_size[msg]:
        result = set_minimum_size(client, msg.surface_id, msg.width, msg.height);

      case set_maximum_size[msg]:
        result = set_maximum_size(client, msg.surface_id, msg.width, msg.height);

      case move[msg]:
        result = move(client, msg.serial, msg.surface_id);

      case resize[msg]:
        result = resize(client, msg.serial, msg.surface_id, msg.tether);

      else:
        completer.raise(zidl::errc::bad_dispatch);
    }

    if (!result)
    {
      std::print("winton compositor: client error - ", cast<winton::errc>(-cast<i32>(result)));

      zidl::send<winton::compositor::error_response>(client.channel, 0, cast<winton::errc>(-cast<i32>(result)));
    }
  });

  if (!result)
  {
    std::print("winton compositor: client error - ", cast<zidl::errc>(-cast<i32>(result)));

    close(client.compositor, client);
  }
}

fn create_surface(client mut *client, u32 id) -> result
{
  if (client.surfaces.contains(id))
    return winton::errc::already_exists;

  var mut &surface = client.surfaces.emplace(id);

  surface.id = id;
  surface.client = client;

  var now = os::timespec(void);
  os::clock_time(os::clock::monotonic, &now);

  surface.uuid.data1 = cast(now & 0xffffffff);
  surface.uuid.data2 = cast((now >> 32) & 0xffff);
  surface.uuid.data3 = cast((now >> 48) & 0xffff);
  surface.uuid.data4 = [ 0xb4, 0x8b, 0xb7, 0x4c, 0x9d, 0x84, 0x85, 0xb8 ];

  zidl::send<winton::compositor::surface_response>(client.channel, surface.id, surface.uuid);

  return 0;
}

fn create_buffer(client mut *client, u32 id, zidl::buffer handle, u32 offset, i32 width, i32 height, i32 stride, winton::format format) -> result
{
  if (client.buffers.contains(id))
    return winton::errc::already_exists;

  var stat = os::stat();
  if (var rc = os::stat(&mut thread_ring, handle.fd, &stat, 0x7f); rc < 0)
    return winton::errc::descriptor_error;

  if (width <= 0 || height <= 0 || stride < width)
    return winton::errc::invalid_buffer_size;

  if (stat.size < cast<u64>(offset) + cast<u64>(height) * cast<u64>(stride))
    return winton::errc::buffer_size_overflow;

  var mmvec = os::mmvec();
  mmvec.offset = 0;
  mmvec.length = cast(stat.size);
  mmvec.flags = 0;
  mmvec.prot = os::prot::readonly;

  var addr = null<u8 mut *>();
  if (var rc = os::mmap(handle.fd, &mmvec, 1, &addr, 0); rc < 0)
    return winton::errc::descriptor_error;

  var mut &buffer = client.buffers.emplace(id);

  buffer.id = id;
  buffer.width = width;
  buffer.height = height;
  buffer.offset = cast(offset);
  buffer.stride = cast(stride);
  buffer.format = format;
  buffer.size = mmvec.length;
  buffer.data = addr;

  return 0;
}

fn surface_attach(client mut *client, u32 surface_id, u32 buffer_id) -> result
{
  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      surface.pending = client.buffers.get(buffer_id);

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn surface_damage(client mut *client, u32 surface_id, i32 x, i32 y, i32 width, i32 height) -> result
{
  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      surface.pending_damage = expand(surface.pending_damage, bound::from(vec2(cast(x), cast(y)), vec2(cast(x + width), cast(y + height))));

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn surface_commit(client mut *client, u32 surface_id, bool callback) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (surface.active)
      {
        release(client, &*surface, &*surface.active.value);

        surface.active.clear();
      }

      if (surface.pending)
      {
        surface.pending_width = surface.pending.value.width;
        surface.pending_height = surface.pending.value.height;
        surface.damage = expand(surface.damage, clamp(surface.pending_damage, surface.pending.value.bound));
        surface.pending_damage.clear();

        std::swap(&mut surface.active, &mut surface.pending);
      }

      if (!surface.node)
        return 0;

      switch (*surface.node)
      {
        case window[window]:
          if (window.flags != surface.pending_flags)
          {
            if (surface.pending_flags & (winton::state::maximised | winton::state::fullscreen))
              compositor.scene.set_transform(window, transform::translation(0.0, 0.0, 0.0));

            if ((window.flags & winton::state::maximised) && !(surface.pending_flags & winton::state::maximised))
              compositor.scene.set_transform(window, surface.restore_local);

            if ((window.flags & winton::state::fullscreen) && !(surface.pending_flags & winton::state::fullscreen))
              compositor.scene.set_transform(window, surface.restore_local);

            surface.resize_tether = cast(0);
          }

          if (window.width != surface.pending_width || window.height != surface.pending_height || window.flags != surface.pending_flags)
          {
            if (cast<i32>(surface.resize_tether) & cast<i32>(winton::tether::left) != 0)
              compositor.scene.set_transform(window, window.local * transform::translation(cast(window.width - surface.pending_width), 0.0, 0.0));

            if (cast<i32>(surface.resize_tether) & cast<i32>(winton::tether::top) != 0)
              compositor.scene.set_transform(window, window.local * transform::translation(0.0, cast(window.height - surface.pending_height), 0.0));

            if (!window.bound.empty)
              compositor.damage = expand(compositor.damage, window.world * window.bound);

            compositor.pointer.dirty_focus = true;
          }

          compositor.scene.set_state(window, surface.pending_width, surface.pending_height, surface.pending_flags);
          compositor.scene.set_constraints(window, surface.pending_min_width, surface.pending_min_height, surface.pending_max_width, surface.pending_max_height);
          compositor.scene.set_visible_region(window, surface.pending_visible_region);
          compositor.scene.set_opaque_region(window, surface.pending_opaque_region);
          compositor.scene.set_input_region(window, surface.pending_input_region);

        case cursor[cursor]:
          if (cursor.width != surface.pending_width || cursor.height != surface.pending_height)
            compositor.damage = expand(compositor.damage, cursor.world * cursor.bound);

          compositor.scene.set_size(cursor, surface.pending_width, surface.pending_height);
      }

      if (surface.pending_flags & winton::state::minimised)
      {
        compositor.scene.erase(surface.node);

        if (compositor.keyboard.focus == surface.node)
        {
          compositor.keyboard.focus = null;

          keyboard_activate(compositor, compositor.scene.topmost);
        }

        if (compositor.pointer.focus == surface.node)
          compositor.pointer.focus = null;

        surface.node = null;
      }

      if (surface.state & surface::state::mapped != surface::state::mapped)
        configure(client, &*surface);

      surface.callback = callback;

      if (compositor.status & compositor::status::scheduled != compositor::status::scheduled)
        schedule_redraw(compositor, &*surface);

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn surface_destroy(client mut *client, u32 surface_id) -> result
{
  var j = client.surfaces.find(surface_id);

  if (j == client.surfaces.end)
    return winton::errc::invalid_surface;

  client.surfaces.erase(j);

  return 0;
}

fn buffer_resize(client mut *client, u32 buffer_id, u32 offset, i32 width, i32 height, i32 stride, winton::format format) -> result
{
  var compositor = client.compositor;

  switch (client.buffers.get(buffer_id))
  {
    case Some[buffer]:

      if (width <= 0 || height <= 0 || stride < width)
        return winton::errc::invalid_buffer_size;

      if (buffer.size < cast<usize>(offset) + cast<usize>(height) * cast<usize>(stride))
        return winton::errc::buffer_size_overflow;

      buffer.width = width;
      buffer.height = height;
      buffer.offset = cast(offset);
      buffer.stride = cast(stride);
      buffer.format = format;

    else:
      return winton::errc::invalid_buffer;
  }

  return 0;
}

fn buffer_destroy(client mut *client, u32 buffer_id) -> result
{
  var j = client.buffers.find(buffer_id);

  if (j == client.buffers.end)
    return winton::errc::invalid_buffer;

  client.buffers.erase(j);

  return 0;
}

fn create_window(client mut *client, u32 surface_id) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (surface.node)
        return winton::errc::invalid_surface;

      surface.node = compositor.scene.create_window(&*surface, scene::scene::layers::normal);

      surface.pending_input_region = bound::from(vec2(-10000.0, -10000.0), vec2(10000.0, 10000.0));

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn create_popup(client mut *client, u32 surface_id, u32 parent_id) -> result
{

  return 0;
}

fn configure(client mut *client, surface mut *surface) -> result
{
  var serial = client.serial = std::add_with_carry(client.serial, 1).0;

  switch (*surface.node)
  {
    case window[window]:
      surface.configure_serial = serial;

      zidl::send<winton::compositor::configure_window_response>(client.channel, surface.id, surface.incoming_width, surface.incoming_height, surface.incoming_flags);
  }

  zidl::send<winton::compositor::configure_response>(client.channel, serial, surface.id);

  return 0;
}

fn acknowledge(client mut *client, u32 serial) -> result
{
  var compositor = client.compositor;

  for (var mut &[id, surface] : client.surfaces)
  {
    if (surface.configure_serial != serial)
      continue;

    surface.pending_flags = surface.incoming_flags;

    if (surface.state & surface::state::mapped != surface::state::mapped)
    {
      switch (*surface.node)
      {
        case window[window]:

          var x = compositor.placement.x;
          var y = compositor.placement.y;
          var width = surface.pending_visible_region.width;
          var height = surface.pending_visible_region.height;

          if (x + width + 10.0 > cast(compositor.display.width))
            x = 20.0;

          if (y + height + 10.0 > cast(compositor.display.height))
            y = 50.0;

          compositor.scene.set_transform(window, transform::translation(x, y, 0.0));

          compositor.placement.x = x + width + 20.0;
          compositor.placement.y = y + 20.0;
      }

      keyboard_activate(compositor, surface.node);

      surface.state |= surface::state::mapped;
    }
  }

  return 0;
}

fn release(client mut *client, surface mut *surface, buffer mut *buffer) -> result
{
  if (buffer.id != 0)
  {
    zidl::send<winton::compositor::surface_release_response>(client.channel, surface.id, buffer.id);
  }

  return 0;
}

fn callback(client mut *client, surface mut *surface, u64 time) -> result
{
  zidl::send<winton::compositor::surface_callback_response>(client.channel, surface.id, time);

  surface.callback = false;

  return 0;
}

fn pointer_enter(client mut *client, surface mut *surface, vec2 position) -> result
{
  var serial = client.serial = std::add_with_carry(client.serial, 1).0;

  zidl::send<winton::compositor::pointer_enter_response>(client.channel, serial, surface.id, cast<i32>(position.x + 0.5), cast<i32>(position.y + 0.5));

  client.compositor.pointer.focus_serial = serial;

  return 0;
}

fn pointer_leave(client mut *client, surface mut *surface) -> result
{
  var serial = client.serial = std::add_with_carry(client.serial, 1).0;

  zidl::send<winton::compositor::pointer_leave_response>(client.channel, serial, surface.id);

  return 0;
}

fn pointer_motion(client mut *client, surface mut *surface, u64 time, vec2 position) -> result
{
  zidl::send<winton::compositor::pointer_motion_response>(client.channel, surface.id, time, cast<i32>(position.x + 0.5), cast<i32>(position.y + 0.5));

  return 0;
}

fn pointer_button(client mut *client, surface mut *surface, u64 time, u32 button, u32 state) -> result
{
  zidl::send<winton::compositor::pointer_button_response>(client.channel, surface.id, time, button, state);

  return 0;
}

fn pointer_wheel(client mut *client, surface mut *surface, u64 time, f32 dx, f32 dy) -> result
{
  zidl::send<winton::compositor::pointer_wheel_response>(client.channel, surface.id, time, cast<i32>(dx), cast<i32>(dy));

  return 0;
}

fn keyboard_enter(client mut *client, surface mut *surface) -> result
{
  var serial = client.serial = std::add_with_carry(client.serial, 1).0;

  zidl::send<winton::compositor::keyboard_enter_response>(client.channel, serial, surface.id);

  client.compositor.keyboard.focus_serial = serial;

  surface.incoming_flags |= winton::state::activated;

  configure(client, surface);

  return 0;
}

fn keyboard_leave(client mut *client, surface mut *surface) -> result
{
  var serial = client.serial = std::add_with_carry(client.serial, 1).0;

  zidl::send<winton::compositor::keyboard_leave_response>(client.channel, serial, surface.id);

  surface.incoming_flags &= ~winton::state::activated;

  configure(client, surface);

  return 0;
}

fn keyboard_modifiers(client mut *client, surface mut *surface, u64 time, winton::modifiers modifiers) -> result
{
  zidl::send<winton::compositor::keyboard_modifiers_response>(client.channel, surface.id, time, modifiers);

  return 0;
}

fn keyboard_key(client mut *client, surface mut *surface, u64 time, u32 key, u32 state, char sym) -> result
{
  zidl::send<winton::compositor::keyboard_key_response>(client.channel, surface.id, time, key, state, sym);

  return 0;
}

fn set_cursor(client mut *client, u32 serial, u32 surface_id, i32 hotspot_x, i32 hotspot_y) -> result
{
  var compositor = client.compositor;

  if (serial != compositor.pointer.focus_serial)
    return 0;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (surface.node)
      {
        if (&*surface != compositor.pointer.surface)
          return winton::errc::invalid_surface;

        // todo: update hotspot
        // invalidate old and new

        return 0;
      }

      if (compositor.pointer.surface)
        destroy(compositor.pointer.surface);

      surface.node = compositor.scene.create_cursor(&*surface, compositor.pointer.position, hotspot_x, hotspot_y);

      surface.state |= surface::state::mapped;

      compositor.pointer.surface = &*surface;

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn set_standard_cursor(client mut *client, u32 serial, u32 surface_id, winton::cursor cursor) -> result
{
  var compositor = client.compositor;

  if (serial != compositor.pointer.focus_serial)
    return 0;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (surface.node)
      {
        if (&*surface != compositor.pointer.surface)
          return winton::errc::invalid_surface;
      }

      if (compositor.pointer.surface)
        destroy(compositor.pointer.surface);

      switch (cursor)
      {
        case none:
        case arrow:
        case resize_top:
        case resize_left:
        case resize_bottom:
        case resize_right:
        case resize_top_left:
        case resize_top_right:
        case resize_bottom_left:
        case resize_bottom_right:
          var &cursor = compositor.theme.cursors[cast(cursor)];

          surface.node = compositor.scene.create_cursor(&*surface, compositor.pointer.position, cursor.hotspot_x, cursor.hotspot_y);

          surface.pending = cursor.sprite.buffer;
          surface.pending_damage = bound::max();

        else:
          return winton::errc::invalid_cursor;
      }

      surface.state |= surface::state::mapped;

      compositor.pointer.surface = &*surface;

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn set_minimised(client mut *client, u32 surface_id) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      surface.incoming_flags |= winton::state::minimised;

      configure(client, &*surface);

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn set_maximised(client mut *client, u32 surface_id) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      surface.restore_width = surface.pending_width;
      surface.restore_height = surface.pending_height;
      surface.restore_local = surface.node.transform;
      surface.incoming_width = compositor.display.width;
      surface.incoming_height = compositor.display.height;
      surface.incoming_flags |= winton::state::maximised;

      configure(client, &*surface);

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn set_fullscreen(client mut *client, u32 surface_id) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      surface.restore_width = surface.pending_width;
      surface.restore_height = surface.pending_height;
      surface.restore_local = surface.node.transform;
      surface.incoming_width = compositor.display.width;
      surface.incoming_height = compositor.display.height;
      surface.incoming_flags |= winton::state::fullscreen;

      configure(client, &*surface);

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn unset_maximised(client mut *client, u32 surface_id) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      if (!(surface.incoming_flags & winton::state::maximised))
        return 0;

      surface.incoming_width = surface.restore_width;
      surface.incoming_height = surface.restore_height;
      surface.incoming_flags &= ~winton::state::maximised;

      configure(client, &*surface);

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn unset_fullscreen(client mut *client, u32 surface_id) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      if (!(surface.incoming_flags & winton::state::fullscreen))
        return 0;

      surface.incoming_width = surface.restore_width;
      surface.incoming_height = surface.restore_height;
      surface.incoming_flags &= ~winton::state::fullscreen;

      configure(client, &*surface);

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn set_visible_region(client mut *client, u32 surface_id, i32 x, i32 y, i32 width, i32 height) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      surface.pending_visible_region = bound::from(vec2(cast(x), cast(y)), vec2(cast(x + width), cast(y + height)));

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn set_opaque_region(client mut *client, u32 surface_id, i32 x, i32 y, i32 width, i32 height) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      surface.pending_opaque_region = bound::from(vec2(cast(x), cast(y)), vec2(cast(x + width), cast(y + height)));

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn set_input_region(client mut *client, u32 surface_id, i32 x, i32 y, i32 width, i32 height) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      surface.pending_input_region = bound::from(vec2(cast(x), cast(y)), vec2(cast(x + width), cast(y + height)));

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn set_minimum_size(client mut *client, u32 surface_id, i32 width, i32 height) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      surface.pending_min_width = width;
      surface.pending_min_height = height;

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn set_maximum_size(client mut *client, u32 surface_id, i32 width, i32 height) -> result
{
  var compositor = client.compositor;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      surface.pending_max_width = width;
      surface.pending_max_height = height;

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn move(client mut *client, u32 serial, u32 surface_id) -> result
{
  var compositor = client.compositor;

  if (serial != compositor.pointer.focus_serial)
    return 0;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      if (surface.node != compositor.pointer.focus)
        return 0;

      if (compositor.pointer.pressed_count == 0)
        return 0;

      if (compositor.pointer.grab_op != grab::none)
        return 0;

      if (surface.pending_flags & (winton::state::maximised | winton::state::fullscreen))
        return 0;

      compositor.pointer.grab_op = grab::move;
      compositor.pointer.grab_offset = project(inverse(surface.node.transform), compositor.pointer.grab_pos);

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn resize(client mut *client, u32 serial, u32 surface_id, winton::tether tether) -> result
{
  var compositor = client.compositor;

  if (serial != compositor.pointer.focus_serial)
    return 0;

  switch (client.surfaces.get(surface_id))
  {
    case Some[surface]:

      if (!surface.node)
        return winton::errc::not_configured;

      if (surface.node != compositor.pointer.focus)
        return 0;

      if (compositor.pointer.pressed_count == 0)
        return 0;

      if (compositor.pointer.grab_op != grab::none)
        return 0;

      compositor.pointer.grab_op = grab::resize;
      compositor.pointer.grab_bound = surface.active.value.bound;
      surface.resize_tether = tether;

    else:
      return winton::errc::invalid_surface;
  }

  return 0;
}

fn destroy(buffer mut *buffer) -> void
{
  if (buffer.data)
    os::munmap(buffer.data, buffer.size);
}

fn destroy(surface mut *surface) -> void
{
  var compositor = surface.client.compositor;

  if (surface.node)
  {
    switch (*surface.node)
    {
      case window[window]:
        compositor.damage = expand(compositor.damage, window.world * window.bound);

      case cursor[cursor]:
        compositor.damage = expand(compositor.damage, cursor.world * cursor.bound);
    }

    compositor.scene.erase(surface.node);

    if (compositor.keyboard.focus == surface.node)
    {
      compositor.keyboard.focus = null;

      keyboard_activate(compositor, compositor.scene.topmost);
    }

    if (compositor.status & compositor::status::scheduled != compositor::status::scheduled)
      schedule_redraw(compositor, surface);

    compositor.pointer.dirty_focus = true;
  }

  if (compositor.keyboard.focus == surface.node)
    compositor.keyboard.focus = null;

  if (compositor.pointer.focus == surface.node)
    compositor.pointer.focus = null;

  if (compositor.pointer.surface == surface)
    compositor.pointer.surface = null;

  surface.node = null;
  surface.active.clear();
  surface.pending.clear();
  surface.callback = false;
  surface.state = cast(0);
}

fn destroy(client mut *client) -> void
{
  app::loop::current.cancel_wait(&client.handler);
}

fn close(compositor mut *compositor, client mut *client) -> void
{
  compositor.clients.erase_if(|k| &*k == client);
}

fn schedule_redraw(compositor mut *compositor, surface mut *surface) -> void
{
  std::assert(compositor.status & compositor::status::scheduled != compositor::status::scheduled);

  var now = os::timespec(void);
  os::clock_time(os::clock::monotonic, &now);

  if (compositor.redraw_handler.deadline < now)
    compositor.redraw_handler.deadline = now;

  app::loop::current.begin_timeout(&compositor.redraw_handler);

  compositor.status |= compositor::status::scheduled;
}

fn redraw_handler(app::loop mut &loop, app::loop::timeout_t mut *timeout) -> void
{
  var compositor = cast<compositor mut *>(cast<uintptr>(timeout) - offsetof(compositor::redraw_handler));

  var now = os::timespec(void);
  os::clock_time(os::clock::monotonic, &now);

  compositor.scene.update(1.0/60.0);

  if (compositor.pointer.dirty_focus)
    pointer_motion(compositor, now, compositor.pointer.position);

  var mut &display = compositor.display;

  var view_list = compositor.scene.build_view_list();

  for (var node : view_list)
  {
    var surface = cast<surface mut *>(node.surface);

    if (surface.callback)
      callback(surface.client, surface, now);

    compositor.damage = expand(compositor.damage, node.transform * surface.damage);
  }

  for (var node : view_list)
  {
    var surface = cast<surface mut *>(node.surface);

    switch (surface.active)
    {
      case Some[buffer]:
        var transform = node.transform;
        var translation = transform.translation;

        //display.blit(compositor.damage, transform, buffer.width, buffer.height, buffer.stride, buffer.data + buffer.offset, cast(buffer.format));
        display.blit(compositor.damage, translation, buffer.width, buffer.height, buffer.stride, buffer.data + buffer.offset, cast(buffer.format));
    }

    surface.damage.clear();
  }

  display.flip(compositor.damage);

  compositor.damage.clear();

  timeout.deadline += display.dt;
  compositor.status &= ~compositor::status::scheduled;
}

fn pointer_motion(compositor mut *compositor, u64 time, vec2 position) -> void
{
  var mut &pointer = compositor.pointer;

  var oldpos = pointer.position;

  pointer.position = clamp(&move position, compositor.display.bound);
  pointer.position.x = std::floor(pointer.position.x + 0.5);
  pointer.position.y = std::floor(pointer.position.y + 0.5);

  if (pointer.pressed_count == 0)
  {
    var [node, xy] = compositor.scene.pick(pointer.position);

    if (pointer.focus != node)
    {
      if (pointer.focus)
      {
        var surface = cast<surface mut *>(pointer.focus.surface);

        pointer_leave(surface.client, surface);
      }

      pointer.focus = node;

      if (pointer.focus)
      {
        var surface = cast<surface mut *>(pointer.focus.surface);

        keyboard_modifiers(surface.client, surface, time, compositor.keyboard.modifiers);

        pointer_enter(surface.client, surface, xy);
      }
    }
  }

  if (pointer.focus)
  {
    var surface = cast<surface mut *>(pointer.focus.surface);

    switch (pointer.grab_op)
    {
      case move:
        switch (*pointer.focus)
        {
          case window[window]:
            var dp = project(inverse(window.parent.transform * window.local), pointer.position) - pointer.grab_offset;

            compositor.scene.set_transform(window, window.local * transform::translation(dp.x, dp.y, 0.0));

            compositor.damage = expand(compositor.damage, window.world * window.bound);
            compositor.damage = expand(compositor.damage, window.parent.transform * window.local * window.bound);

            if (compositor.status & compositor::status::scheduled != compositor::status::scheduled)
              schedule_redraw(compositor, surface);
        }

      case resize:
        switch (*pointer.focus)
        {
          case window[window]:
            var dp = project(inverse(window.world), pointer.position) - project(inverse(window.world), pointer.grab_pos);

            surface.incoming_width = cast(pointer.grab_bound.high(0));
            surface.incoming_height = cast(pointer.grab_bound.high(1));

            if (cast<i32>(surface.resize_tether) & cast<i32>(winton::tether::left) != 0)
              surface.incoming_width -= cast(dp.x);

            if (cast<i32>(surface.resize_tether) & cast<i32>(winton::tether::right) != 0)
              surface.incoming_width += cast(dp.x);

            if (cast<i32>(surface.resize_tether) & cast<i32>(winton::tether::top) != 0)
              surface.incoming_height -= cast(dp.y);

            if (cast<i32>(surface.resize_tether) & cast<i32>(winton::tether::bottom) != 0)
              surface.incoming_height += cast(dp.y);

            if (surface.incoming_width < 1)
              surface.incoming_width = 1;

            if (window.min_width != 0 && surface.incoming_width < window.min_width)
              surface.incoming_width = window.min_width;

            if (window.max_width != 0 && surface.incoming_width > window.max_width)
              surface.incoming_width = window.max_width;

            if (surface.incoming_height < 1)
              surface.incoming_height = 1;

            if (window.min_height != 0 && surface.incoming_height < window.min_height)
              surface.incoming_height = window.min_height;

            if (window.max_height != 0 && surface.incoming_height > window.max_height)
              surface.incoming_height = window.max_height;

            configure(surface.client, surface);
        }

      else:
        pointer_motion(surface.client, surface, time, project(inverse(surface.node.transform), pointer.position));
    }
  }

  if (pointer.surface && pointer.surface.node)
  {
    var &cursor = pointer.surface.node.cursor;

    compositor.scene.set_position(cursor, pointer.position);

    compositor.damage = expand(compositor.damage, transform::translation(oldpos.x - cursor.hotspot_x, oldpos.y - cursor.hotspot_y, 0.0) * cursor.bound);
    compositor.damage = expand(compositor.damage, transform::translation(pointer.position.x - cursor.hotspot_x, pointer.position.y - cursor.hotspot_y, 0.0) * cursor.bound);

    if (compositor.status & compositor::status::scheduled != compositor::status::scheduled)
      schedule_redraw(compositor, pointer.surface);
  }

  pointer.dirty_focus = false;
}

fn pointer_button(compositor mut *compositor, u64 time, u32 button, u32 state) -> void
{
  var mut &pointer = compositor.pointer;
  var mut &keyboard = compositor.keyboard;

  switch (state)
  {
    case input::button_state::pressed:
      pointer.pressed_count += 1;

      if (pointer.pressed_count == 1)
        pointer.grab_pos = pointer.position;

    case input::button_state::released:
      pointer.pressed_count -= 1;

      if (pointer.pressed_count == 0)
        pointer.grab_op = grab::none;
  }

  if (pointer.focus)
  {
    var surface = cast<surface mut *>(pointer.focus.surface);

    if (keyboard.focus != pointer.focus)
      keyboard_activate(compositor, pointer.focus);

    pointer_button(surface.client, surface, time, button, state);
  }

  if (pointer.pressed_count == 0)
  {
    pointer_motion(compositor, time, pointer.position);
  }
}

fn pointer_wheel(compositor mut *compositor, u64 time, f32 dx, f32 dy) -> void
{
  var mut &pointer = compositor.pointer;

  if (pointer.focus)
  {
    var surface = cast<surface mut *>(pointer.focus.surface);

    pointer_wheel(surface.client, surface, time, dx, dy);
  }
}

fn keyboard_key(compositor mut *compositor, u64 time, u32 key, u32 state, char sym) -> void
{
  var mut &keyboard = compositor.keyboard;

  var modifiers = keyboard.modifiers;

  switch (key)
  {
    case input::Key::LeftShift:
    case input::Key::RightShift:

      if (state == 0 && keyboard.shift_state != 0 && (keyboard.shift_state -= 1) == 0)
        modifiers &= ~winton::modifiers::shift;

      if (state == 1 && (keyboard.shift_state += 1) == 1)
        modifiers |= winton::modifiers::shift;

    case input::Key::LeftControl:
    case input::Key::RightControl:

      if (state == 0 && keyboard.control_state != 0 && (keyboard.control_state -= 1) == 0)
        modifiers &= ~winton::modifiers::control;

      if (state == 1 && (keyboard.control_state += 1) == 1)
        modifiers |= winton::modifiers::control;

    case input::Key::LeftAlt:
    case input::Key::RightAlt:

      if (state == 0 && keyboard.alt_state != 0 && (keyboard.alt_state -= 1) == 0)
        modifiers &= ~winton::modifiers::alt;

      if (state == 1 && (keyboard.alt_state += 1) == 1)
        modifiers |= winton::modifiers::alt;

    case input::Key::CapsLock:

      if (state == 1)
        modifiers ^= winton::modifiers::capslock;

    case input::Key::NumLock:

      if (state == 1)
        modifiers ^= winton::modifiers::numlock;

    case input::Key::ScrollLock:

      if (state == 1)
        modifiers ^= winton::modifiers::scrolllock;
  }

  if (modifiers != keyboard.modifiers)
  {
    if (keyboard.focus)
    {
      var surface = cast<surface mut *>(keyboard.focus.surface);

      keyboard_modifiers(surface.client, surface, time, modifiers);
    }

    if (compositor.pointer.focus && compositor.pointer.focus != keyboard.focus)
    {
      var surface = cast<surface mut *>(compositor.pointer.focus.surface);

      keyboard_modifiers(surface.client, surface, time, modifiers);
    }

    keyboard.modifiers = modifiers;
  }

  if (keyboard.focus)
  {
    var surface = cast<surface mut *>(keyboard.focus.surface);

    keyboard_key(surface.client, surface, time, key, state, sym);
  }
}

fn keyboard_activate(compositor mut *compositor, scene::node *node) -> void
{
  var mut &keyboard = compositor.keyboard;

  if (keyboard.focus != node)
  {
    if (keyboard.focus)
    {
      var surface = cast<surface mut *>(keyboard.focus.surface);

      keyboard_leave(surface.client, surface);
    }

    keyboard.focus = node;

    if (keyboard.focus)
    {
      var surface = cast<surface mut *>(keyboard.focus.surface);

      compositor.scene.raise(keyboard.focus);

      compositor.damage = expand(compositor.damage, compositor.display.bound);

      if (compositor.status & compositor::status::scheduled != compositor::status::scheduled)
        schedule_redraw(compositor, surface);

      keyboard_enter(surface.client, surface);
    }
  }
}

fn input_handler(compositor mut *compositor, input::event &event) -> void
{
  switch (event)
  {
    case keyboard_key[evt]:
      keyboard_key(compositor, evt.time, cast(evt.key), cast(evt.state), evt.sym);

    case pointer_motion_rel[evt]:
      pointer_motion(compositor, evt.time, vec2(compositor.pointer.position.x + cast(evt.x), compositor.pointer.position.y - cast(evt.y)));

    case pointer_motion_abs[evt]:
      pointer_motion(compositor, evt.time, vec2(cast<f32>(compositor.display.width) * cast(evt.x), cast<f32>(compositor.display.height) * cast(evt.y)));

    case pointer_button[evt]:
      pointer_button(compositor, evt.time, cast(evt.button), cast(evt.state));

    case pointer_wheel[evt]:
      pointer_wheel(compositor, evt.time, cast(evt.x), cast(evt.y));
  }
}

pub fn create_desktop(compositor mut &compositor, winton::uuid &surface_id) -> result
{
  for (var mut &client : compositor.clients)
  {
    for (var mut &[id, surface] : client.surfaces)
    {
      if (surface_id == surface.uuid)
      {
        if (surface.node)
          return winton::errc::invalid_surface;

        surface.node = compositor.scene.create_window(&*surface, scene::scene::layers::desktop);

        surface.incoming_width = compositor.display.width;
        surface.incoming_height = compositor.display.height;
        surface.incoming_flags |= winton::state::fullscreen;

        surface.pending_input_region = bound::from(vec2(-10000.0, -10000.0), vec2(10000.0, 10000.0));
      }
    }
  }

  return ok;
}
