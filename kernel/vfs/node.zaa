//
// vfs node
//

import std.string;
import vfs.fd;
import vfs.stat;
import vfs.notify;
import vfs.result;
import blk;
import io;
import vm;
import mutex as _ : mutex;
import process as _ : process;
import support.rc : Rc;

pub struct node
{
  pub enum type
  {
    file,
    directory,
    symlink,
    volume,
    device,
    watchset,
    pollset,
    ioring,
    event,
    buffer,
    channel,
    //socket,
  }

  pub union ops
  {
    pub file(node_file_operations *),
    pub directory(node_directory_operations *),
    pub symlink(node_symlink_operations *),
    pub volume(node_volume_operations *),
    pub stream(node_stream_operations *),
    pub device(node_device_operations *),

    pub ops() = default;
    pub ops(ops &) = default;
    pub fn =(ops mut &, ops &) ->ops mut & = default;
    pub ~ops() = default;
  }

  pub type type;
  pub Rc<node> covers;
  pub Rc<node> covered;

  pub u64 watching;
  pub Rc<vfs::watchlist> watchlist;

  pub fn node_operations(this &) -> node_operations *
  {
    switch (this.ops)
    {
      case file[ops]:
        return ops;

      case directory[ops]:
        return ops;

      case symlink[ops]:
        return ops;

      case volume[ops]:
        return ops;

      case stream[ops]:
        return ops;

      case device[ops]:
        return ops;

      else:
        std::panic("illegal ops type");
    }
  }

  pub fn file_operations(this &) -> node_file_operations *
  {
    switch (this.ops)
    {
      case file[ops]:
        return ops;

      case volume[ops]:
        return ops;

      else:
        std::panic("illegal ops type");
    }
  }

  pub fn directory_operations(this &) -> node_directory_operations *
  {
    switch (this.ops)
    {
      case directory[ops]:
        return ops;

      else:
        std::panic("illegal ops type");
    }
  }

  pub fn symlink_operations(this &) -> node_symlink_operations *
  {
    switch (this.ops)
    {
      case symlink[ops]:
        return ops;

      else:
        std::panic("illegal ops type");
    }
  }

  pub fn volume_operations(this &) -> node_volume_operations *
  {
    switch (this.ops)
    {
      case volume[ops]:
        return ops;

      else:
        std::panic("illegal ops type");
    }
  }

  pub fn stream_operations(this &) -> node_stream_operations *
  {
    switch (this.ops)
    {
      case stream[ops]:
        return ops;

      case device[ops]:
        return ops;

      else:
        std::panic("illegal ops type");
    }
  }

  pub fn device_operations(this &) -> node_device_operations *
  {
    switch (this.ops)
    {
      case device[ops]:
        return ops;

      else:
        std::panic("illegal ops type");
    }
  }

  pub fn ref(this mut &) -> void
  {
    std::atomic_add(&this.refcnt, 1);
  }

  pub fn unref(this mut &) -> void
  {
    if (std::atomic_sub(&this.refcnt, 1) == 1)
      destroy(&this);
  }

  pub node(type type, node_operations &ops)
    : type(type), ops(&ops)
  {
  }

  pub fn init(node mut *this, type type, ops &ops) -> void
  {
    this.type = type;
    this.ops = ops;
  }

  pub node() = default;
  pub ~node() = default;

  i32 refcnt;
  ops ops;
}

pub vtable node_operations
{
  pub fn open(vfs::node mut *node, vfs::fd mut &fd, process mut *process, u64 flags, u32 mode) -> vfs::result;

  pub fn getstat(vfs::node mut *node, vfs::stat mut &stat, u64 mask) -> vfs::result;
  pub fn putstat(vfs::node mut *node, vfs::stat &stat, u64 mask) -> vfs::result;

  fn destroy(vfs::node mut *node) -> void;
}

pub vtable node_file_operations : node_operations
{
  pub fn read(vfs::node mut *node, Rc<io::iocb> mut &cb, u64 position, vm::iovec &iovec, usize offset, usize length) -> vfs::result;
  pub fn write(vfs::node mut *node, Rc<io::iocb> mut &cb, u64 position, vm::iovec &iovec, usize offset, usize length) -> vfs::result;
}

pub vtable node_directory_operations : node_operations
{
  pub fn lookup(vfs::node mut *path, std::string_view name) -> Rc<vfs::node>;
  pub fn create(vfs::node mut *path, std::string_view name, Rc<vfs::node> mut &dentry, u32 uid, u32 gid, u32 mode) -> vfs::result;
  pub fn symlink(vfs::node mut *path, std::string_view name, std::string_view target, Rc<vfs::node> mut &dentry, u32 uid, u32 gid, u32 mode) -> vfs::result;
  pub fn mkdir(vfs::node mut *path, std::string_view name, Rc<vfs::node> mut &dentry, u32 uid, u32 gid, u32 mode) -> vfs::result;
  pub fn rename(vfs::node mut *oldpath, std::string_view oldname, vfs::node mut *newpath, std::string_view newname) -> vfs::result;
  pub fn link(vfs::node mut *oldpath, std::string_view oldname, vfs::node mut *newpath, std::string_view newname) -> vfs::result;
  pub fn readdir(vfs::node mut *node, u64 mut &cursor, vm::iovec &iovec, usize offset, usize length) -> vfs::result;
  pub fn unlink(vfs::node mut *path, std::string_view name) -> vfs::result;
  pub fn notify(vfs::node mut *path, vfs::node mut *node, u64 mask, std::string_view name) -> vfs::result;
}

pub vtable node_symlink_operations : node_operations
{
  pub fn readlink(vfs::node mut *node, std::string mut &buffer) -> vfs::result;
}

pub vtable node_volume_operations : node_file_operations
{
  pub fn ioctl(vfs::node mut *node, u32 op, vm::iovec &iovec) -> vfs::result;
}

pub vtable node_stream_operations : node_operations
{
  pub fn poll(vfs::node mut *node, Rc<io::iocb> mut &readable, Rc<io::iocb> mut &writeable) -> vfs::result;
  pub fn read(vfs::node mut *node, vm::iovec &iovec, usize offset, usize length) -> vfs::result;
  pub fn write(vfs::node mut *node, vm::iovec &iovec, usize offset, usize length) -> vfs::result;
}

pub vtable node_device_operations : node_stream_operations
{
  pub fn ioctl(vfs::node mut *node, u32 op, vm::iovec &iovec) -> vfs::result;
  pub fn mmap(vfs::node mut *node, vm::virtrange range, u64 offset, vm::protection prot, vm::usage use) -> vfs::result;
}

fn destroy(node mut *node) -> void
{
  vfs::unwatch(node);
  blk::purge(node);

  node.node_operations.destroy(node);
}
