//
// cpu
//

import std.atomic;
import sys;
import scheduler : run_queue;
import thread as _ : thread;
import platform;

pub struct cpu_logical_core
{
  pub int id;
  pub thread mut *current_thread;

  pub u64 cyc2ns;
  pub u64 clockspeed;

  pub run_queue runqueue;

  pub u64 active_time;
  pub u64 interrupt_time;
  pub u64 idle_time;

  pub u64 process_counter_interrupt_time;
  pub usize process_counter_user_allocated_pages;

  cpu_logical_core() = default;
  cpu_logical_core(#cpu_logical_core&) = default;
  ~cpu_logical_core() = default;
}

fn self() -> cpu_logical_core mut &
{
  extern static thread_local cpu_logical_core = #cpu_logical_core();

  return &cpu_logical_core;
}

pub struct irq_lock
{
  bool state;

  pub fn lock(this mut &) -> void
  {
    this.state = platform::disable_interrupts();
  }

  pub fn unlock(this mut &) -> void
  {
    platform::restore_interrupts(this.state);
  }

  irq_lock() = default;
  irq_lock(#irq_lock&) = default;
  ~irq_lock() = default;
}

pub fn irqlock() -> irq_lock
{
  return irq_lock();
}

pub fn interrupts_disabled() -> bool
{
  return platform::interrupts_disabled;
}

pub fn id() -> int
{
  return platform::percpu_load<int>("cpu_logical_core", offsetof(cpu_logical_core::id));
}

pub fn current_thread() -> thread mut *
{
  return platform::percpu_load<thread mut *>("cpu_logical_core", offsetof(cpu_logical_core::current_thread));
}

pub fn current() -> cpu_logical_core mut *
{
  std::assert(platform::interrupts_disabled);

  return platform::percpu_addr<cpu_logical_core mut *>("cpu_logical_core");
}

pub fn runqueue() -> run_queue mut &
{
  std::assert(platform::interrupts_disabled);

  return platform::percpu_addr<run_queue mut &>("cpu_logical_core", offsetof(cpu_logical_core::runqueue));
}

pub fn switch_current_thread(thread mut *thread) -> void
{
  std::assert(platform::interrupts_disabled);

  self.current_thread = thread;
}

pub fn increment_interrupt_time(u64 time)
{
  platform::percpu_add("cpu_logical_core", offsetof(cpu_logical_core::process_counter_interrupt_time), time);
}

pub fn increment_user_allocated_pages()
{
  platform::percpu_inc("cpu_logical_core", offsetof(cpu_logical_core::process_counter_user_allocated_pages));
}

pub fn tsc() -> u64
{
  return platform::rdtsc();
}

pub fn cyc2ns() -> u64
{
  return self.cyc2ns;
}

pub fn clockspeed() -> u64
{
  return self.clockspeed;
}

pub fn system_time() -> u64
{
  return std::mul_with_carry(tsc, self.cyc2ns).1;
}

pub fn bootstrap(platform::BootInfo &bootinfo, int cpu) -> void
{
  self.id = cpu;
  self.clockspeed = bootinfo.early_tsc_frequency;
  self.cyc2ns = ((1_000_000_000 << 32) / self.clockspeed) << 32;

  sys::add_cpu(cpu, &self);
}
