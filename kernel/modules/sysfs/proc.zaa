//
// sysfs proc
//

import std.alloc;
import std.flat_hash_map;
import sysfs.proc;
import vfs.node;
import vfs.stat;
import vfs.fs;
import vm;
import io;
import process as _ : process;
import mutex as _ : shared_mutex;
import support.rc : Rc;
import support.json : json_stream;
import chrono;

pub struct proc_pid_node : pub sysfs::sysfs_directory_node
{
  process::id pid;

  pub fn create(vfs::node_ptr &&parent, process::id pid) -> vfs::node_ptr
  {
    return vfs::node_ptr(std::allocator::new<proc_pid_node>(&&parent, pid));
  }

  pub proc_pid_node(vfs::node_ptr &&parent, process::id pid)
    : super(&impl this, &&parent),
      pid(pid)
  {
  }

  pub fn open(vfs::node_ptr &node, vfs::fd mut &fd, u64 flags, u32 mode) -> vfs::result
  {
    var process = process::find(cast<proc_pid_node mut &>(*node).pid);

    if (!process)
      return not_found;

    return ok;
  }

  pub fn getattr(vfs::node_ptr &node, vfs::stat mut &stat, u64 mask) -> vfs::result
  {
    var process = process::find(cast<proc_pid_node mut &>(*node).pid);

    if (!process)
      return not_found;

    //stat.uid = process.uid;
    //stat.gid = process.gid;

    return ok;
  }

  pub fn lookup(vfs::node_ptr &path, std::string_view name) -> vfs::node_ptr
  {
    var &this = cast<proc_pid_node&>(*path);

    if (name == "stat")
      return proc_stat_node::create(path, this.pid);

    if (name == "auxv")
      return proc_auxv_node::create(path, this.pid);

    if (name == "environ")
      return proc_environ_node::create(path, this.pid);

    if (name == "cmdline")
      return proc_cmdline_node::create(path, this.pid);

    return vfs::node_ptr();
  }

  pub fn readdir(vfs::node_ptr &node, u64 mut &cursor, std::delegate<(vfs::ftype, std::string_view) -> vm::result> mut &emit) -> vfs::result
  {
    emit(vfs::ftype::regular_file, std::string_view("stat"));
    emit(vfs::ftype::regular_file, std::string_view("auxv"));
    emit(vfs::ftype::regular_file, std::string_view("environ"));
    emit(vfs::ftype::regular_file, std::string_view("cmdline"));
    emit(vfs::ftype::regular_file, std::string_view("pagemap"));
    emit(vfs::ftype::symbolic_link, std::string_view("exe"));

    return ok;
  }

  fn destroy(vfs::node mut *node) -> void
  {
    std::allocator::delete(cast<proc_pid_node mut *>(node));
  }

  pub ~proc_pid_node() = default;
}

pub struct proc_stat_node : pub sysfs::sysfs_file_node
{
  process::id pid;

  pub fn create(vfs::node_ptr &&parent, process::id pid) -> vfs::node_ptr
  {
    return vfs::node_ptr(std::allocator::new<proc_stat_node>(&&parent, pid));
  }

  pub proc_stat_node(vfs::node_ptr &&parent, process::id pid)
    : super(&impl this, &&parent),
      pid(pid)
  {
  }

  pub fn open(vfs::node_ptr &node, vfs::fd mut &fd, u64 flags, u32 mode) -> vfs::result
  {
    var mut &this = cast<proc_stat_node mut &>(*node);

    var process = process::find(this.pid);

    if (!process)
      return io_error;

    if (flags & 0x3 != 0)
    {
      var json = std::string();
      var stream = json_stream(&mut json);

      stream.begin('{');
      stream.append("pid", process.id);
      stream.append("name", process.name);
      stream.append("state", std::meta::enumerator_name(process.state));

      stream.begin("threads", '[');

      process.enumerate_threads(|thread| [json, stream] {
        stream.begin('{');
        stream.append("tid", thread.id);
        stream.append("state", std::meta::enumerator_name(thread.state));
        stream.append("cpu", thread.cpu);
        stream.append("cpu_time", thread.cpu_time);
        stream.append("priority", cast<int>(thread.priority));
        stream.end('}');
      });

      stream.end(']');

      stream.end('}');

      this.contents = &move json;
    }

    return ok;
  }

  pub fn getattr(vfs::node_ptr &node, vfs::stat mut &stat, u64 mask) -> vfs::result
  {
    return ok;
  }

  pub fn write(vfs::node_ptr &node, u64 position, vm::iovec &buffer, usize offset, usize length) -> vfs::result
  {
    return not_supported;
  }

  fn destroy(vfs::node mut *node) -> void
  {
    std::allocator::delete(cast<proc_stat_node mut *>(node));
  }

  pub ~proc_stat_node() = default;
}

pub struct proc_auxv_node : pub sysfs::sysfs_file_node
{
  process::id pid;

  pub fn create(vfs::node_ptr &&parent, process::id pid) -> vfs::node_ptr
  {
    return vfs::node_ptr(std::allocator::new<proc_auxv_node>(&&parent, pid));
  }

  pub proc_auxv_node(vfs::node_ptr &&parent, process::id pid)
    : super(&impl this, &&parent),
      pid(pid)
  {
  }

  pub fn open(vfs::node_ptr &node, vfs::fd mut &fd, u64 flags, u32 mode) -> vfs::result
  {
    var mut &this = cast<proc_auxv_node mut &>(*node);

    var process = process::find(this.pid);

    if (!process)
      return io_error;

    if (flags & 0x3 != 0)
    {
      var json = std::string();
      var stream = json_stream(&mut json);

      stream.begin('{');

      for (var &arg : process.auxv)
      {
        stream.append(std::meta::enumerator_name(arg.type), arg.value);
      }

      stream.end('}');

      this.contents = &move json;
    }

    return ok;
  }

  pub fn getattr(vfs::node_ptr &node, vfs::stat mut &stat, u64 mask) -> vfs::result
  {
    return ok;
  }

  pub fn write(vfs::node_ptr &node, u64 position, vm::iovec &buffer, usize offset, usize length) -> vfs::result
  {
    return not_supported;
  }

  fn destroy(vfs::node mut *node) -> void
  {
    std::allocator::delete(cast<proc_auxv_node mut *>(node));
  }

  pub ~proc_auxv_node() = default;
}

pub struct proc_environ_node : pub sysfs::sysfs_file_node
{
  process::id pid;

  pub fn create(vfs::node_ptr &&parent, process::id pid) -> vfs::node_ptr
  {
    return vfs::node_ptr(std::allocator::new<proc_environ_node>(&&parent, pid));
  }

  pub proc_environ_node(vfs::node_ptr &&parent, process::id pid)
    : super(&impl this, &&parent),
      pid(pid)
  {
  }

  pub fn open(vfs::node_ptr &node, vfs::fd mut &fd, u64 flags, u32 mode) -> vfs::result
  {
    var mut &this = cast<proc_environ_node mut &>(*node);

    var process = process::find(this.pid);

    if (!process)
      return io_error;

    if (flags & 0x3 != 0)
    {
      var json = std::string();
      var stream = json_stream(&mut json);

      stream.begin('[');

      for (var arg : process.envp)
      {
        stream.begin('"');

        json.reserve(json.len + arg.size);

        if (var result = vm::read_process_memory(process, arg.addr, json.end, arg.size); !result)
          return cast(result);

        stream.append_from_capacity(arg.size);

        stream.end('"');
      }

      stream.end(']');

      this.contents = &move json;
    }

    return ok;
  }

  pub fn getattr(vfs::node_ptr &node, vfs::stat mut &stat, u64 mask) -> vfs::result
  {
    return ok;
  }

  pub fn write(vfs::node_ptr &node, u64 position, vm::iovec &buffer, usize offset, usize length) -> vfs::result
  {
    return not_supported;
  }

  fn destroy(vfs::node mut *node) -> void
  {
    std::allocator::delete(cast<proc_environ_node mut *>(node));
  }

  pub ~proc_environ_node() = default;
}

pub struct proc_cmdline_node : pub sysfs::sysfs_file_node
{
  process::id pid;

  pub fn create(vfs::node_ptr &&parent, process::id pid) -> vfs::node_ptr
  {
    return vfs::node_ptr(std::allocator::new<proc_cmdline_node>(&&parent, pid));
  }

  pub proc_cmdline_node(vfs::node_ptr &&parent, process::id pid)
    : super(&impl this, &&parent),
      pid(pid)
  {
  }

  pub fn open(vfs::node_ptr &node, vfs::fd mut &fd, u64 flags, u32 mode) -> vfs::result
  {
    var mut &this = cast<proc_cmdline_node mut &>(*node);

    var process = process::find(this.pid);

    if (!process)
      return io_error;

    if (flags & 0x3 != 0)
    {
      var json = std::string();
      var stream = json_stream(&mut json);

      stream.begin('[');

      for (var arg : process.argv)
      {
        stream.begin('"');

        json.reserve(json.len + arg.size);

        if (var result = vm::read_process_memory(process, arg.addr, json.end, arg.size); !result)
          return cast(result);

        stream.append_from_capacity(arg.size);

        stream.end('"');
      }

      stream.end(']');

      this.contents = &move json;
    }

    return ok;
  }

  pub fn getattr(vfs::node_ptr &node, vfs::stat mut &stat, u64 mask) -> vfs::result
  {
    return ok;
  }

  pub fn write(vfs::node_ptr &node, u64 position, vm::iovec &buffer, usize offset, usize length) -> vfs::result
  {
    return not_supported;
  }

  fn destroy(vfs::node mut *node) -> void
  {
    std::allocator::delete(cast<proc_cmdline_node mut *>(node));
  }

  pub ~proc_cmdline_node() = default;
}

pub struct proc_root_node : pub sysfs::sysfs_directory_node
{
  pub fn create(vfs::node_ptr &&parent) -> vfs::node_ptr
  {
    return vfs::node_ptr(std::allocator::new<proc_root_node>(&&parent));
  }

  pub proc_root_node(vfs::node_ptr &&parent)
    : super(&impl this, &&parent)
  {
  }

  pub fn open(vfs::node_ptr &node, vfs::fd mut &fd, u64 flags, u32 mode) -> vfs::result
  {
    return ok;
  }

  pub fn getattr(vfs::node_ptr &node, vfs::stat mut &stat, u64 mask) -> vfs::result
  {
    return ok;
  }

  pub fn lookup(vfs::node_ptr &path, std::string_view name) -> vfs::node_ptr
  {
    var &this = cast<proc_root_node&>(*path);

    if (name == "list")
      return proc_list_node::create(path);

    var pid = process::id();
    if (std::atoi(name.begin, name.end, &mut pid).error)
      return vfs::node_ptr();

    var process = process::find(pid);

    if (!process)
      return vfs::node_ptr();

    return proc_pid_node::create(path, pid);
  }

  pub fn readdir(vfs::node_ptr &node, u64 mut &cursor, std::delegate<(vfs::ftype, std::string_view) -> vm::result> mut &emit) -> vfs::result
  {
    var result = vm::result::ok;

    process::enumerate(|process| [result, cursor, emit] {
      if (!result)
        return;

      var buf = [0; 64];
      var len = std::sprint(&mut buf, process.id);

      if (result = emit(vfs::ftype::directory, std::string_view(buf.data, len)); !result)
        return;

      cursor += 1;
    });

    emit(vfs::ftype::regular_file, std::string_view("list"));

    return cast(result);
  }

  fn destroy(vfs::node mut *node) -> void
  {
    std::allocator::delete(cast<proc_root_node mut *>(node));
  }

  pub ~proc_root_node() = default;
}

pub struct proc_list_node : pub sysfs::sysfs_file_node
{
  pub fn create(vfs::node_ptr &&parent) -> vfs::node_ptr
  {
    return vfs::node_ptr(std::allocator::new<proc_list_node>(&&parent));
  }

  pub proc_list_node(vfs::node_ptr &&parent)
    : super(&impl this, &&parent)
  {
  }

  pub fn open(vfs::node_ptr &node, vfs::fd mut &fd, u64 flags, u32 mode) -> vfs::result
  {
    var mut &this = cast<proc_list_node mut &>(*node);

    if (flags & 0x3 != 0)
    {
      var json = std::string();
      var stream = json_stream(&mut json);

      stream.begin('[');

      process::enumerate(|process| [json, stream] {
        stream.begin('{');
        stream.append("pid", process.id);
        stream.append("name", process.name);
        stream.append("state", std::meta::enumerator_name(process.state));
        stream.end('}');
      });

      stream.end(']');

      this.contents = &move json;
    }

    return ok;
  }

  pub fn getattr(vfs::node_ptr &node, vfs::stat mut &stat, u64 mask) -> vfs::result
  {
    return ok;
  }

  pub fn write(vfs::node_ptr &node, u64 position, vm::iovec &buffer, usize offset, usize length) -> vfs::result
  {
    return not_supported;
  }

  fn destroy(vfs::node mut *node) -> void
  {
    std::allocator::delete(cast<proc_list_node mut *>(node));
  }

  pub ~proc_list_node() = default;
}
