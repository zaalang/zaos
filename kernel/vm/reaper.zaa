//
// vm
//

import std.stdio;
import vm;
import blk;
import sys;
import thread as _ : thread;
import process as _ : process;
import semaphore as _ : semaphore;
import scheduler;
import platform;

struct reaper
{
  thread mut *reaper;
  semaphore doorbell;
  semaphore ringtone;

  fn instance()
  {
    static instance = #reaper();

    return &instance;
  }

  reaper() = default;
  reaper(#reaper&) = default;
  ~reaper() = default;
}

fn reaper(void *) -> void
{
  var mut &reaper = reaper::instance;

  for (;;)
  {
    reaper.doorbell.wait();

    std::print("reaper: ", vm::available_physical_memory, " ", blk::cache_memory_used);

    blk::reap();
    process::reap();

    vm::reap();

    if (vm::available_physical_memory + blk::cache_memory_used < 67_108_864)
      oom_kill_process();

    for (var i = reaper.doorbell.value; i != 0; --i)
    {
      reaper.doorbell.wait();
      reaper.ringtone.release();
    }

    reaper.ringtone.release();
  }
}

pub fn wake_and_wait() -> void
{
  var mut &reaper = reaper::instance;

  reaper.doorbell.release();
  reaper.ringtone.wait();
}

pub fn spawn_reaper() -> void
{
  var mut &reaper = reaper::instance;

  reaper.doorbell.maxvalue = ~0;
  reaper.ringtone.maxvalue = ~0;

  reaper.reaper = create_thread(process::current, &cast<(void mut *) -> void>(reaper), null);

  reaper.reaper.pinned = true;

  scheduler::enqueue(reaper.reaper, thread::priority::high);
}
